// Outros Casos de Uso (e.g., GetTaskStatusUseCase)​
​
public TaskController(SubmitTaskUseCase submitTaskUseCase) {​
this.submitTaskUseCase = submitTaskUseCase;​
}​
​
@PostMapping​
public ResponseEntity<TaskSubmissionApiResponse> submitTask(​
@Valid @RequestBody TaskSubmissionApiRequest apiRequest) {​
​
// Mapear DTO da API para Comando do Caso de Uso​
SubmitTaskCommand command = new SubmitTaskCommand(​apiRequest.submitterNodeId(),​
apiRequest.taskType(),​
apiRequest.payloadHash(), // Supondo que o payloadHash já está calculado​
apiRequest.resourceRequirements(), // Supondo que ResourceProfile é parte
do DTO​
Instant.parse(apiRequest.deadlineIso8601()), // Validar formato​
apiRequest.securityRequirements(),​
apiRequest.priority()​
//... outros campos de TaskDefinition​
);​
​
TaskReceiptDto receipt = submitTaskUseCase.execute(command);​
​
// Mapear DTO de resposta do Caso de Uso para DTO da API​
TaskSubmissionApiResponse apiResponse = new
TaskSubmissionApiResponse(​
receipt.taskId(),​
receipt.status().toString(), // Adaptar conforme necessário​
receipt.submissionTimestamp().toString()​
);​
return ResponseEntity.status(HttpStatus.CREATED).body(apiResponse);​
}​
// Outros endpoints: GET /tasks/{taskId}, GET /tasks?status=PENDING, etc.​
}​
●​ DTOs da API (Java Records):
○​ Definir Records específicos para os payloads de requisição e resposta da API
(e.g., TaskSubmissionApiRequest, TaskSubmissionApiResponse). Estes podem
ser diferentes dos DTOs usados internamente pela camada de aplicação para
permitir a evolução independente da API.
○​ Utilizar anotações Bean Validation (@NotBlank, @NotNull, @Size, @Pattern)
nos DTOs de requisição para validação automática de entrada.
●​ Segurança da API:
○​ Proteger os endpoints com Spring Security.
○​ Utilizar um mecanismo de autenticação robusto, como tokens JWT assinados
com algoritmos PQC (e.g., ML-DSA). O token conteria a identidade do cliente
e suas permissões.
○​ Implementar autorização baseada em roles ou permissões granulares para
controlar o acesso a diferentes endpoints e funcionalidades.●​ Tratamento de Erros:
○​ Usar @ControllerAdvice e @ExceptionHandler no Spring MVC para traduzir
exceções lançadas pelas camadas inferiores (e.g., NodeNotFoundException,
TaskSubmissionException, ValidationException) em respostas HTTP
padronizadas e significativas (e.g., 400 Bad Request, 404 Not Found, 500
Internal Server Error).
A camada de infraestrutura, portanto, atua como a ponte entre a lógica de negócio
pura da Atous e o mundo tecnológico externo, implementando os detalhes
necessários para persistência, comunicação, segurança e exposição de
funcionalidades, sempre respeitando os contratos definidos pelas camadas internas.
VI. Dominando a Concorrência: Virtual Threads e Structured
Concurrency do Java 21 na Atous
A Rede Atous, sendo um sistema distribuído de alta performance e baixa latência,
depende crucialmente de um modelo de concorrência eficiente para lidar com um
grande volume de operações simultâneas, especialmente aquelas vinculadas a I/O
(entrada/saída), como comunicação P2P, interações com Kafka e Redis, e
processamento de requisições de API. O Java 21 introduz as Virtual Threads (VT)
como uma funcionalidade padrão e a Structured Concurrency (em preview, mas com
um caminho claro para estabilização) como um paradigma para simplificar e
robustecer o código concorrente.
A. Aplicação Estratégica de Virtual Threads nos Componentes da Atous
Virtual Threads são threads leves gerenciadas pela JVM, projetadas para aumentar
significativamente o throughput de aplicações que lidam com um grande número de
tarefas bloqueantes concorrentes.32 Quando uma VT executa uma operação de I/O
bloqueante, ela é "desmontada" da thread de plataforma (kernel thread) subjacente,
permitindo que esta execute outra VT. Isso possibilita que o sistema suporte milhões
de VTs simultaneamente com um número relativamente pequeno de platform threads.
●​ Camada de Rede P2P:
○​ Este é o caso de uso primário para VTs na Atous. Cada conexão P2P de
entrada e cada operação de envio/recebimento de mensagens para um peer
pode ser tratada por sua própria Virtual Thread.1 Isso simplifica o código do
servidor P2P, permitindo um estilo de programação "thread-por-conexão"
que é mais fácil de ler e depurar, sem a complexidade de modelos
assíncronos baseados em callbacks ou programação reativa para I/O.
●​ Executores de Tarefas (Task Execution Workers):○​ Se as tarefas distribuídas pela Atous envolvem operações de I/O (e.g., buscar
dados de uma fonte externa, interagir com outros serviços, escrever
resultados em armazenamento), cada instância de execução de tarefa pode
rodar em uma VT.
●​ Consumidores e Produtores Kafka:
○​ Com a propriedade spring.threads.virtual.enabled=true no Spring Boot 3.2+,
os listeners @KafkaListener e as operações do KafkaTemplate que são
I/O-bound podem ser executados em Virtual Threads, melhorando a
capacidade de processamento de mensagens concorrentes.1
●​ Controladores REST:
○​ Similarmente, com a configuração global de VTs no Spring Boot, as
requisições HTTP recebidas pelos @RestControllers serão processadas por
Virtual Threads, permitindo que o servidor lide com um número muito maior
de requisições simultâneas, especialmente se os handlers realizarem
chamadas a outros serviços ou bancos de dados.1
●​ Operações PQC:
○​ Algumas operações PQC (especialmente geração de chaves ou assinaturas
com algoritmos mais pesados) podem ser computacionalmente intensivas e,
se envolverem qualquer espera (e.g., por entropia de um SecureRandom
bloqueante, ou acesso a HSMs via rede), podem ser candidatas a serem
offloaded para VTs para não bloquear platform threads críticas. No entanto,
VTs são primariamente para I/O-bound; para CPU-bound puro, platform
threads ainda são mais adequadas. A decisão aqui depende da natureza
exata da operação PQC.
B. Melhores Práticas para Prevenir "Pinning" e Maximizar Throughput
O "pinning" ocorre quando uma Virtual Thread fica "presa" à sua platform thread
portadora durante uma operação bloqueante, impedindo que a portadora seja
liberada para executar outras VTs. Isso anula os benefícios de escalabilidade das
VTs.32 É crucial evitar ou minimizar o pinning.
●​ Cenários Comuns de Pinning:
○​ Blocos ou Métodos synchronized: Se uma VT entra em um bloco
synchronized e então realiza uma operação bloqueante (I/O), ela fica pinned.32
○​ Chamadas a Métodos Nativos (JNI) Bloqueantes: Se uma VT chama um
método JNI que bloqueia a thread nativa.32
●​ Estratégias de Mitigação:
○​ Substituir synchronized por java.util.concurrent.locks.ReentrantLock:
Para seções críticas que envolvem I/O ou outras operações bloqueantes queprecisam ser executadas por VTs, ReentrantLock (e outros locks do
java.util.concurrent) não causam pinning.35 O JDK 24 introduziu melhorias
para reduzir o pinning com synchronized em certos cenários, mas a
recomendação geral para código novo em VTs ainda pende para
ReentrantLock quando I/O está envolvido dentro da seção crítica.34
■​ Exemplo (Problemático vs. Recomendado):​
Java​
// Problemático com Virtual Threads se makeDBCall() for bloqueante​
public synchronized void synchronizedDataAccess() {​
//...​
makeDBCall(); // Se bloqueante, a VT fica pinned​
//...​
}​
​
// Recomendado com Virtual Threads​
private final ReentrantLock dbLock = new ReentrantLock();​
public void reentrantLockDataAccess() {​
dbLock.lock();​
try {​
//...​
makeDBCall(); // VT pode ser desmontada se makeDBCall() bloquear​
//...​
} finally {​
dbLock.unlock();​
}​
}​
○​ Design Cuidadoso de Chamadas JNI: Se chamadas JNI forem inevitáveis e
bloqueantes, encapsulá-las e, se possível, executá-las em um pool dedicado
de platform threads, comunicando-se com as VTs de forma assíncrona.
○​ Monitoramento e Diagnóstico: Utilizar o JDK Flight Recorder (JFR) para
detectar eventos jdk.VirtualThreadPinned. Isso ajuda a identificar e corrigir
gargalos de pinning em produção ou ambientes de teste.32
A adoção de Virtual Threads na Atous deve ser acompanhada de uma diretriz clara de
desenvolvimento: evitar synchronized em caminhos de código que executam I/O e são
destinados a VTs. Revisões de código devem ativamente procurar por esses padrões.
Esta disciplina é essencial para que a Atous realize plenamente os benefícios de
escalabilidade prometidos pelas VTs.C. Explorando Structured Concurrency (Java 21 Preview - JEP 453)
Structured Concurrency (JEP 453, em preview no JDK 21, e estabilizada como JEP 462
no JDK 22) é um paradigma que visa simplificar o desenvolvimento de código
concorrente, tornando-o mais confiável, manutenível e observável.37 Ela trata grupos
de tarefas relacionadas que rodam em diferentes threads (idealmente VTs) como uma
única unidade de trabalho. A classe principal é
java.util.concurrent.StructuredTaskScope.
●​ Principais Conceitos:
○​ StructuredTaskScope: Um escopo que gerencia o ciclo de vida de um grupo
de sub-tarefas concorrentes. Geralmente usado em um bloco
try-with-resources para garantir o fechamento e a junção (join) das tarefas.
○​ fork(Callable<T> task): Submete uma tarefa para execução em uma nova
thread (VT por padrão) dentro do escopo. Retorna um Supplier<T> (ou
Future<T> em versões mais antigas da JEP).
○​ join(): Aguarda a conclusão de todas as tarefas bifurcadas no escopo.
○​ Políticas de Encerramento (Shutdown Policies):
■​ StructuredTaskScope.ShutdownOnFailure: Se qualquer sub-tarefa
falhar (lançar uma exceção), todas as outras sub-tarefas ainda em
execução no escopo são canceladas (via interrupção), e o método join()
lança uma exceção. Ideal para cenários "all-or-nothing" onde o sucesso
de todas as sub-tarefas é necessário.37
■​ StructuredTaskScope.ShutdownOnSuccess<T>: Se qualquer
sub-tarefa for concluída com sucesso, todas as outras sub-tarefas ainda
em execução são canceladas. O método result() do escopo retorna o
resultado da primeira tarefa bem-sucedida. Ideal para cenários
"first-to-succeed" (e.g., consultar várias fontes redundantes para o
mesmo dado e usar a primeira resposta).37
●​ Aplicação na Atous vNext:​
A Atous, com suas múltiplas interações distribuídas, pode se beneficiar
significativamente da clareza e robustez da Structured Concurrency.
○​ Processamento Paralelo de Sub-tarefas: Se uma TaskDefinition complexa
for decomposta em várias sub-tarefas que podem ser executadas em
paralelo em diferentes nós (ou mesmo localmente), o nó orquestrador pode
usar StructuredTaskScope com ShutdownOnFailure. Se qualquer sub-tarefa
falhar, ou se a tarefa principal for cancelada, todas as outras sub-tarefas
associadas são automaticamente canceladas. Isso previne computações
órfãs e vazamento de recursos, contribuindo para a meta de "tolerância zero
a falhas".■​ Exemplo Conceitual (Orquestração de Sub-tarefas):​
Java​
// No nó orquestrador​
public TaskOverallResult processDistributedTask(List<SubTaskCallable> subTasks) ​
throws InterruptedException, ExecutionException {​
try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {​
List<Supplier<SubTaskResult>> results = new ArrayList<>();​
for (SubTaskCallable subTask : subTasks) {​
// subTask.setTargetNodeId(selectNodeForSubTask(...));​
// networkClient.dispatch(subTask) -> retorna um Supplier que completa quando
o resultado volta​
results.add(scope.fork(() ->
networkClient.executeRemoteSubTask(subTask)));​
}​
scope.join().throwIfFailed(); // Espera todas ou falha na primeira​
​
// Coletar e agregar resultados se todas foram bem-sucedidas​
return aggregateResults(results.stream().map(Supplier::get).toList());​
}​
}​
○​ Difusão de Mensagens com Quórum: Ao difundir uma mensagem
importante na rede P2P (e.g., uma proposta de bloco no RWA-BFT) e esperar
por um quórum de respostas/confirmações, StructuredTaskScope pode ser
usado. Uma política customizada ou ShutdownOnSuccess (se adaptada para
contar N sucessos) poderia gerenciar as respostas.
○​ Coleta de Telemetria de Múltiplos Nós: Ao agregar telemetria de um
conjunto de nós, as coletas individuais podem ser bifurcadas. Se a falha em
obter telemetria de alguns nós não for crítica, uma política mais branda pode
ser usada.
○​ Consultas a Fontes de Dados Redundantes no NIS: Se o NIS precisar
consultar múltiplas fontes (internas ou externas) para dados de inteligência
de ameaças, ShutdownOnSuccess pode ser usado para obter a informação
da fonte mais rápida.
●​ Contraste com ExecutorService 38:​
A Structured Concurrency oferece vantagens significativas sobre o
gerenciamento manual de Futures com ExecutorService:
○​ Ciclo de Vida Claro: O ciclo de vida das tarefas concorrentes está vinculado
ao escopo do bloco try-with-resources. Quando o escopo é fechado, todas
as tarefas são garantidamente concluídas ou canceladas.○​ Propagação de Cancelamento: Se a thread que executa o
StructuredTaskScope for interrompida, a interrupção é propagada para todas
as sub-tarefas, evitando vazamentos de threads. Com ExecutorService, o
cancelamento de Futures deve ser gerenciado manualmente e é mais
propenso a erros.
○​ Tratamento de Erros Simplificado: Políticas como ShutdownOnFailure
simplificam o tratamento de falhas em grupos de tarefas, cancelando
automaticamente o trabalho desnecessário. Com ExecutorService, é preciso
iterar sobre Futures, verificar exceções individualmente e implementar lógica
de cancelamento customizada.
○​ Observabilidade: A estrutura hierárquica das tarefas facilita o rastreamento
e a depuração em dumps de thread e ferramentas de profiling.
Embora a Structured Concurrency ainda esteja em preview no Java 21, sua inclusão
no design da Atous vNext demonstra um compromisso com as práticas modernas de
concorrência em Java, visando um código mais robusto, resiliente e fácil de manter. A
equipe deve monitorar sua evolução para a versão estável e adaptar a implementação
conforme necessário.
VII. Bootstrap, Configuração e Integridade Modular
A inicialização, configuração e a integridade estrut
Works cited
1.​ Paper_Tecnico_Guia_Implementacao_Atous.pdf
2.​ Clean Architecture with Spring Boot | Baeldung, accessed June 8, 2025,
https://www.baeldung.com/spring-boot-clean-architecture
3.​ Spring Boot Multi Module Project : r/SpringBoot - Reddit, accessed June 8, 2025,
https://www.reddit.com/r/SpringBoot/comments/1gerzq6/spring_boot_multi_mod
ule_project/
4.​ MOEA Framework - Wikipedia, accessed June 8, 2025,
https://en.wikipedia.org/wiki/MOEA_Framework
5.​ MOEAFramework/MOEAFramework: A Free and Open ... - GitHub, accessed
June 8, 2025, https://github.com/MOEAFramework/MOEAFramework
6.​ Advances in Distributed Scheduling Algorithms: A Three-Layer Architecture
Integrating Deep Reinforcement Learning and Energy Optimization (2023-2024) |
Journal of Al-Qadisiyah for Computer Science and Mathematics, accessed June
8, 2025, https://jqcsm.qu.edu.iq/index.php/journalcm/article/view/1963
7.​ TOP 12 Best Java Machine Learning Libraries 2025 - Stepmedia, accessed June 8,
2025, https://stepmediasoftware.com/blog/best-java-machine-learning-libraries/
8.​ Reinforcement Learning for Production Scheduling : The SOLO Method |
GeeksforGeeks, accessed June 8, 2025,https://www.geeksforgeeks.org/reinforcement-learning-for-production-scheduli
ng-the-solo-method/
9.​ ML-KLEM and ML-DSA Post-Quantum Cryptography in .NET - StrathWeb,
accessed June 8, 2025,
https://www.strathweb.com/2025/02/ml-kem-and-ml-dsa-post-quantum-crypto
graphy-in-net/
10.​ML-KEM repeated public key check during encapsulation · Issue #1974 ·
bcgit/bc-java, accessed June 8, 2025,
https://github.com/bcgit/bc-java/issues/1974
11.​ ML-KEM and ML-DSA private key ASN.1 encoding format does not comply with
IETF draft · Issue #1969 · bcgit/bc-java - GitHub, accessed June 8, 2025,
https://github.com/bcgit/bc-java/issues/1969
12.​Bouncy Castle Crypto Package - javadoc.io, accessed June 8, 2025,
https://javadoc.io/static/org.bouncycastle/bctls-jdk14/1.80/specifications.html
13.​Create Post-Quantum Cryptography Keys with Securosys, accessed June 8,
2025,
https://docs.securosys.com/tsb/Tutorials/Post-Quantum-Cryptography/pqc/
14.​Signature verification fails using an OpenSSL-generated ML-DSA-87 Private Key
with BouncyCastle1.8.0 · Issue #2060 · bcgit/bc-java - GitHub, accessed June 8,
2025, https://github.com/bcgit/bc-java/issues/2060
15.​A PQC Almanac - Bouncy Castle, accessed June 8, 2025,
https://downloads.bouncycastle.org/java/docs/PQC-Almanac.pdf
16.​Post quantum cryptography (PQC) - ASecuritySite.com, accessed June 8, 2025,
https://asecuritysite.com/pqc/index
17.​Oracle Releases Java 24, accessed June 8, 2025,
https://www.oracle.com/news/announcement/oracle-releases-java-24-2025-03-1
8/
18.​Java 24: High-Performance & Secure - SQLI, accessed June 8, 2025,
https://www.sqli.com/int-en/insights-news/blog/java-24
19.​What's new in Java 24 - PVS-Studio, accessed June 8, 2025,
https://pvs-studio.com/en/blog/posts/java/1233/
20.​Java 24 Rolls Out Today! Find Out Why It's Aptly Named, accessed June 8, 2025,
https://foojay.io/today/java-24-rolls-out-today-find-out-why-its-aptly-named/
21.​Performance Improvements in JDK 24 - Inside.java, accessed June 8, 2025,
https://inside.java/2025/03/19/performance-improvements-in-jdk24/
22.​Hitchhiker's Guide to Java Performance - JAVAPRO International, accessed June
8, 2025, https://javapro.io/2025/04/07/hitchhikers-guide-to-java-performance/
23.​arXiv:2503.17830v3 [cs.CR] 6 Apr 2025, accessed June 8, 2025,
https://arxiv.org/pdf/2503.17830
24.​Reputation Consensus Mechanism for Blockchain Based on ... - MDPI, accessed
June 8, 2025, https://www.mdpi.com/2079-9292/14/6/1099
25.​Artificial Immune Systems: A Bio-Inspired Paradigm for Computational
Intelligence, accessed June 8, 2025,
https://www.scipublications.com/journal/index.php/jaibd/article/view/1233
26.​Adaptive Intrusion Detection for IoT Networks using Artificial Immune ...,accessed June 8, 2025, https://journal.umy.ac.id/index.php/jrc/article/view/23645
27.​What is Cybersecurity Risk? Definition & Factors to Consider in 2024 -
SecurityScorecard, accessed June 8, 2025,
https://securityscorecard.com/blog/what-is-cybersecurity-risk-factors-to-consid
er/
28.​Protecting Information with Cybersecurity - PMC - PubMed Central, accessed
June 8, 2025, https://pmc.ncbi.nlm.nih.gov/articles/PMC7122347/
29.​A Prototype for Network Intrusion Detection System using Danger Theory -
ResearchGate, accessed June 8, 2025,
https://www.researchgate.net/publication/275221918_A_Prototype_for_Network_I
ntrusion_Detection_System_using_Danger_Theory
30.​Building an Anomaly Based Intrusion Detection System - Journal of the ACS
Advances in Computer Science, accessed June 8, 2025,
https://asc.journals.ekb.eg/article_342505_d7dd71e3b8ef9014efff47951e9412cd.p
df
31.​Artificial Immune System (AIS): A Guide With Python Examples - DataCamp,
accessed June 8, 2025,
https://www.datacamp.com/tutorial/artificial-immune-system
32.​Virtual Threads - Oracle Help Center, accessed June 8, 2025,
https://docs.oracle.com/en/java/javase/21/core/virtual-threads.html
33.​Virtual Threads in Java - GeeksforGeeks, accessed June 8, 2025,
https://www.geeksforgeeks.org/virtual-threads-in-java/
34.​JDK 24's Major Improvement: Virtual Threads Without Pinning - Dan Vega,
accessed June 8, 2025,
https://www.danvega.dev/blog/jdk-24-virtual-threads-without-pinning
35.​Pitfalls to avoid when switching to Virtual threads - yCrash, accessed June 8,
2025, https://blog.ycrash.io/pitfalls-to-avoid-when-switching-to-virtual-threads/
36.​What are reasons not to use virtual threads? : r/java - Reddit, accessed June 8,
2025,
https://www.reddit.com/r/java/comments/1jcpp3f/what_are_reasons_not_to_use_v
irtual_threads/
37.​Create custom Java based extension in Gatling - Stack Overflow, accessed June
8, 2025,
https://stackoverflow.com/questions/78107995/create-custom-java-based-exten
sion-in-gatling
38.​Structured Concurrency, accessed June 8, 2025,
https://docs.oracle.com/en/java/javase/21/core/structured-concurrency.html
39.​Java 21 Structured Concurrency ShutdownOnSuccess and ShutdownOnFailure
understanding - Stack Overflow, accessed June 8, 2025,
https://stackoverflow.com/questions/78041876/java-21-structured-concurrency-s
hutdownonsuccess-and-shutdownonfailure-understan
40.​Nugget Friday - Structured Concurrency in Java - Blog | Payara, accessed June 8,
2025, https://blog.payara.fish/nugget-friday-structured-concurrency-in-java
41.​Structured concurrency and scoped values in Java - SoftwareMill, accessed June
8, 2025,https://softwaremill.com/structured-concurrency-and-scoped-values-in-java/

Guia Abrangente de Segurança para a Rede Atous: OWASP,
Testes de Penetração e Scripts de Verificação
Introdução
Este relatório técnico visa fornecer uma análise de segurança abrangente e um guia
prático para o fortalecimento da Rede Atous, um sistema distribuído de próxima
geração com requisitos rigorosos de segurança, resiliência e desempenho.1 A Rede
Atous integra uma rede peer-to-peer (P2P) de baixa latência, tecnologia blockchain
permissionada, Criptografia Pós-Quântica (PQC) de ponta a ponta, um sistema de
computação com distribuição de carga avançada e uma sofisticada estrutura de
segurança bioinspirada (ABISS/NIS).1 O objetivo primordial é alcançar uma "rede
impenetrável" com "tolerância zero a falhas".1
Para atingir esses objetivos, este documento explora em profundidade os princípios e
as práticas recomendadas pela Open Web Application Security Project (OWASP),
detalha metodologias de testes de penetração (pentest) em aplicações, e fornece
scripts específicos em Java (com Spring), Bash e Python para a verificação exaustiva
da segurança da Rede Atous. A análise se baseia nos materiais de pesquisa
fornecidos, que detalham a arquitetura da Atous, suas tecnologias e seus
componentes de dados, como MySQL, Redis e Kafka.1
A estrutura deste relatório segue uma progressão lógica, iniciando com uma visão
geral do OWASP, suas principais ferramentas e padrões. Em seguida, aborda-se as
metodologias de pentesting, com foco em SAST, DAST, IAST e SCA. Posteriormente,
são apresentados os scripts de teste e as recomendações de segurança específicas
para os diversos componentes da Rede Atous, incluindo sua API REST, a comunicação
P2P, o uso de PQC, o sistema ABISS e as tecnologias de persistência de dados.
Finalmente, são oferecidas conclusões e um roteiro para o fortalecimento contínuo da
segurança da rede.
Seção 1: Visão Geral do OWASP (Open Web Application Security
Project)
O Open Web Application Security Project (OWASP) é uma comunidade online global,
sem fins lucrativos, dedicada a melhorar a segurança de software.2 Através de
projetos de software de código aberto liderados pela comunidade, centenas de
capítulos em todo o mundo, dezenas de milhares de membros e conferências
educacionais e de treinamento, o OWASP tornou-se uma fonte fundamental de
conhecimento e ferramentas para desenvolvedores e profissionais de segurança.3 Oobjetivo principal do OWASP é capacitar as organizações a conceber, desenvolver,
adquirir, operar e manter aplicações que possam ser confiáveis.
1.1. O que é o OWASP e sua Missão?
A missão do OWASP é tornar a segurança de software visível, para que indivíduos e
organizações possam tomar decisões informadas sobre os verdadeiros riscos de
segurança de software. Todos os projetos, ferramentas, documentos, fóruns e
capítulos do OWASP são gratuitos e abertos a qualquer pessoa interessada em
melhorar a segurança de aplicações. O OWASP não é afiliado a nenhuma empresa de
tecnologia, o que garante que suas orientações permaneçam imparciais e
universalmente aplicáveis. A fundação opera como uma comunidade onde a
colaboração e o compartilhamento de conhecimento são incentivados para combater
as causas das falhas de segurança em software.3
1.2. Principais Projetos e Ferramentas OWASP
O OWASP hospeda uma vasta gama de projetos, desde ferramentas de software até
documentação e padrões. Alguns dos projetos mais influentes e amplamente
utilizados incluem:
●​ OWASP Top 10: Uma lista de conscientização padrão que representa um amplo
consenso sobre os riscos de segurança mais críticos para aplicações web.2
●​ OWASP Application Security Verification Standard (ASVS): Um padrão para
realizar verificações de segurança em aplicações web, fornecendo uma base
para testar controles técnicos de segurança e definir requisitos de segurança.5
●​ OWASP Zed Attack Proxy (ZAP): Uma ferramenta popular de teste de
segurança de aplicações web, gratuita e de código aberto, que ajuda a encontrar
vulnerabilidades automaticamente e manualmente.7
●​ OWASP Dependency-Check: Uma ferramenta de Análise de Composição de
Software (SCA) que identifica dependências de projetos e verifica se existem
vulnerabilidades publicamente divulgadas associadas a elas.9
●​ OWASP Cheat Sheet Series (CSS): Uma coleção de guias de boas práticas
concisos e acionáveis para desenvolvedores e defensores de aplicações.3
●​ OWASP Security Knowledge Framework (SKF): Uma ferramenta que pode ser
usada como um guia para construir e verificar aplicações seguras, desde o
design até a implantação.5
Esses projetos, entre muitos outros, fornecem recursos valiosos para integrar a
segurança em todo o ciclo de vida de desenvolvimento de software (SDLC).1.3. Como a Rede Atous Pode se Beneficiar do OWASP
A Rede Atous, com seu foco em ser uma "rede impenetrável" e alcançar "tolerância
zero a falhas", pode se beneficiar imensamente dos recursos do OWASP.1 A aplicação
dos padrões e ferramentas do OWASP pode ajudar a:
●​ Identificar e Mitigar Vulnerabilidades Comuns: Utilizando o OWASP Top 10
como guia e ferramentas como o ZAP para testes DAST.2
●​ Estabelecer Requisitos de Segurança Robustos: Adotando o ASVS como base
para definir e verificar os controles de segurança em todos os componentes da
Atous.5
●​ Gerenciar Riscos de Dependências: Empregando o OWASP
Dependency-Check para analisar as bibliotecas de terceiros usadas no
desenvolvimento Java da Atous.9
●​ Capacitar Desenvolvedores: Utilizando a Cheat Sheet Series para fornecer
orientações práticas sobre codificação segura e modelagem de ameaças.3
●​ Adotar uma Abordagem de Segurança em Profundidade: Integrando as
diversas ferramentas e conhecimentos do OWASP para construir múltiplas
camadas de defesa.
A integração dos princípios do OWASP na arquitetura e nos processos de
desenvolvimento da Atous é um passo fundamental para alcançar seus ambiciosos
objetivos de segurança.
Seção 2: OWASP Top 10 - Riscos Críticos de Segurança em
Aplicações Web
O OWASP Top 10 é um documento de conscientização padrão para desenvolvedores
e segurança de aplicações web. Ele representa um amplo consenso sobre os riscos
de segurança mais críticos para aplicações web.2 O objetivo do Top 10 é aumentar a
conscientização sobre esses riscos, permitindo que as organizações priorizem seus
esforços de mitigação. É importante notar que o OWASP Top 10 não é uma lista
exaustiva de todas as vulnerabilidades possíveis, mas sim um reflexo dos problemas
mais comuns e impactantes observados na indústria.2
2.1. Detalhamento do OWASP Top 10 2021
A versão de 2021 do OWASP Top 10 introduziu algumas mudanças significativas em
relação à edição de 2017, refletindo a evolução do cenário de ameaças e as novas
fontes de dados.4 As categorias são:
1.​ A01:2021-Broken Access Control (Controle de Acesso Quebrado): Estacategoria subiu da quinta posição em 2017 para a primeira em 2021, indicando
sua prevalência e criticidade.4
○​ O que é: Falhas na aplicação de restrições sobre o que usuários autenticados
têm permissão para fazer. Os atacantes podem explorar essas falhas para
acessar funcionalidades e/ou dados não autorizados, visualizar arquivos
sensíveis, modificar dados de outros usuários, alterar direitos de acesso,
etc..12
○​ Como é explorado: Manipulação de parâmetros (e.g., IDs de objetos na URL
ou no corpo da requisição), forçar a navegação para URLs não autorizadas,
escalonamento de privilégios.
○​ Mitigações:
■​ Implementar mecanismos de controle de acesso uma vez e reutilizá-los
em toda a aplicação, incluindo a negação por padrão.13
■​ Modelar controles de acesso para impor a propriedade de registros, em
vez de permitir que o usuário crie, leia, atualize ou exclua qualquer
registro.
■​ Desabilitar a listagem de diretórios no servidor web e garantir que
metadados de arquivos (e.g., .git) e arquivos de backup não estejam
presentes em raízes web.12
■​ Registrar falhas de controle de acesso e alertar administradores quando
apropriado (e.g., falhas repetidas).12
■​ Limitar a taxa de acesso a APIs e controladores para minimizar os danos
de ataques automatizados.12
■​ Identificadores de sessão devem ser invalidados no servidor após o
logout.
2.​ A02:2021-Cryptographic Failures (Falhas Criptográficas): Anteriormente
conhecida como "Exposição de Dados Sensíveis", esta categoria foca em falhas
relacionadas à criptografia (ou sua ausência) que podem levar à exposição de
dados sensíveis.4
○​ O que é: Proteção inadequada de dados sensíveis em trânsito e em repouso.
Isso inclui senhas, números de cartão de crédito, informações de saúde,
dados pessoais identificáveis (PII) e outros dados confidenciais.12 As falhas
podem ocorrer devido a algoritmos fracos, gerenciamento de chaves
inadequado, ou falta de criptografia onde ela é necessária.12
○​ Como é explorado: Interceptação de dados em trânsito não criptografados
(e.g., HTTP), acesso a bancos de dados com dados sensíveis armazenados
em texto plano ou com criptografia fraca, exploração de chaves
criptográficas mal gerenciadas.
○​ Mitigações:■​ Classificar os dados processados, armazenados ou transmitidos pela
aplicação. Identificar quais dados são sensíveis de acordo com leis de
privacidade, requisitos regulatórios ou necessidades de negócios.15
■​ Não armazenar dados sensíveis desnecessariamente. Descartá-los o mais
rápido possível ou usar tokenização ou truncamento se viável.
■​ Criptografar todos os dados sensíveis em repouso.15
■​ Garantir o uso de algoritmos, protocolos e chaves atualizados e fortes.
Usar gerenciamento de chaves adequado.15
■​ Criptografar todos os dados em trânsito com protocolos seguros como
TLS com cifras robustas e Forward Secrecy. Aplicar cabeçalhos como
HTTP Strict Transport Security (HSTS).15
■​ Para senhas, usar funções de hashing adaptativas e salgadas (e.g.,
Argon2, scrypt, bcrypt, PBKDF2) com um fator de trabalho (delay factor)
apropriado.15
■​ Gerar vetores de inicialização (IVs) com um gerador de números
aleatórios criptograficamente seguro (CSPRNG) e garantir que sejam
únicos para cada instância de criptografia ao usar a mesma chave.15
3.​ A03:2021-Injection (Injeção): Esta categoria, que inclui Cross-Site Scripting
(XSS), desceu para a terceira posição.4
○​ O que é: Ocorre quando dados não confiáveis são enviados a um
interpretador como parte de um comando ou consulta. Os dados hostis do
atacante podem enganar o interpretador para executar comandos não
intencionais ou acessar dados não autorizados. Exemplos incluem SQL
injection, NoSQL injection, OS command injection, LDAP injection e XSS.
○​ Como é explorado: Envio de strings maliciosas através de campos de
entrada, parâmetros de URL ou outros vetores de dados que são
processados por um interpretador no backend ou renderizados no navegador
do usuário (para XSS).
○​ Mitigações:
■​ A principal defesa é manter os dados do usuário separados dos
comandos e consultas. Usar APIs seguras que evitem o uso do
interpretador diretamente ou forneçam interfaces parametrizadas (e.g.,
prepared statements para SQL, ORMs).15
■​ Realizar validação de entrada do lado do servidor usando listas de
permissão (positive validation).15
■​ Escapar caracteres especiais usando a sintaxe de escape específica para
o interpretador que está sendo usado.15
■​ Para XSS, aplicar codificação de saída (output encoding) sensível ao
contexto sempre que dados não confiáveis forem renderizados nainterface do usuário. Usar bibliotecas como OWASP Java Encoder.
■​ Usar Content Security Policy (CSP) para mitigar os danos de XSS.
■​ Limitar os resultados de consultas (e.g., com LIMIT em SQL) para reduzir o
impacto de uma injeção bem-sucedida.15
4.​ A04:2021-Insecure Design (Design Inseguro): Uma nova categoria que foca
em riscos relacionados a falhas de design e arquitetura.4
○​ O que é: Falta de controles de segurança no design da aplicação ou um
design que inerentemente leva a vulnerabilidades, mesmo com uma
implementação perfeita. Isso enfatiza a necessidade de modelagem de
ameaças, padrões de design seguros e arquiteturas de referência.
○​ Como é explorado: Depende da falha de design específica. Pode levar a
bypass de lógica de negócios, escalonamento de privilégios, ou exposição de
funcionalidades não intencionais. Um exemplo é a falta de limitação de
tentativas de login, permitindo ataques de força bruta.12
○​ Mitigações:
■​ Estabelecer e usar um ciclo de vida de desenvolvimento seguro com
profissionais de AppSec.
■​ Usar modelagem de ameaças para os componentes críticos de
autenticação, controle de acesso, lógica de negócios e manipulação de
dados sensíveis.11
■​ Integrar princípios e padrões de design seguro.
■​ Escrever testes unitários e de integração para validar que todos os fluxos
críticos são resistentes ao modelo de ameaça. Compilar casos de uso e
de abuso para cada nível de proteção na aplicação.
■​ Segregar os componentes em camadas na arquitetura, com controles de
segurança apropriados em cada camada.
■​ Limitar o consumo de recursos pelo usuário ou serviço.
5.​ A05:2021-Security Misconfiguration (Configuração Incorreta de
Segurança): Esta categoria subiu da sexta posição e agora inclui XML External
Entities (XXE).4
○​ O que é: Falha em implementar todos os controles de segurança apropriados
para um servidor ou aplicação web, ou configurá-los incorretamente.
Exemplos incluem falhas não corrigidas, contas e senhas padrão, listagem de
diretórios habilitada, arquivos e diretórios desprotegidos, ou serviços
desnecessários habilitados.12
○​ Como é explorado: Exploração de configurações padrão inseguras, acesso a
painéis de administração não protegidos, uso de funcionalidades de
depuração deixadas em produção, ou exploração de serviços desnecessários
com vulnerabilidades conhecidas.○​ Mitigações:
■​ Implementar um processo de hardening repetível e automatizado para
configurar os ambientes de forma segura.15
■​ Implantar uma plataforma mínima, removendo ou desabilitando
funcionalidades, componentes, documentação e arquivos de exemplo
desnecessários.15
■​ Revisar e atualizar as configurações de forma rotineira, especialmente
para armazenamento em nuvem (e.g., permissões de buckets S3).15
■​ Segmentar a arquitetura da aplicação com segmentação de rede,
conteinerização ou grupos de segurança na nuvem (ACLs).15
■​ Aplicar cabeçalhos de segurança e validar as configurações de segurança
de forma automatizada.15
6.​ A06:2021-Vulnerable and Outdated Components (Componentes Vulneráveis
e Desatualizados): Anteriormente "Usando Componentes com Vulnerabilidades
Conhecidas", esta categoria subiu da nona posição.4
○​ O que é: Uso de bibliotecas, frameworks e outros módulos de software com
vulnerabilidades conhecidas. Se uma aplicação usa componentes vulneráveis,
ela herda esses riscos.
○​ Como é explorado: Atacantes identificam componentes vulneráveis usados
pela aplicação (e.g., através de fingerprints ou mensagens de erro) e
exploram as vulnerabilidades conhecidas para esses componentes.
○​ Mitigações:
■​ Remover dependências não utilizadas, funcionalidades, componentes,
arquivos e documentação desnecessários.
■​ Inventariar continuamente as versões dos componentes do lado do cliente
e do servidor (e.g., frameworks, bibliotecas) e suas dependências usando
ferramentas como OWASP Dependency-Check.9 Monitorar fontes como
CVE e NVD para vulnerabilidades em componentes.
■​ Adquirir componentes apenas de fontes oficiais por links seguros. Preferir
pacotes assinados para reduzir a chance de incluir um componente
malicioso modificado.
■​ Manter os componentes atualizados e aplicar patches de segurança de
forma oportuna e baseada em risco.
7.​ A07:2021-Identification and Authentication Failures (Falhas de
Identificação e Autenticação): Anteriormente "Autenticação Quebrada", esta
categoria desceu da segunda posição e agora inclui CWEs relacionadas a falhas
de identificação.4
○​ O que é: Funções relacionadas à confirmação da identidade do usuário,
autenticação e gerenciamento de sessão são implementadas incorretamente,permitindo que atacantes comprometam senhas, chaves ou tokens de
sessão, ou explorem outras falhas de implementação para assumir
identidades de outros usuários temporária ou permanentemente.
○​ Como é explorado: Ataques de preenchimento de credenciais (credential
stuffing), força bruta, roubo de tokens de sessão, exploração de
funcionalidades de recuperação de senha fracas.
○​ Mitigações:
■​ Implementar autenticação multifator (MFA) sempre que possível.17
■​ Não enviar ou implantar credenciais padrão, especialmente para usuários
administradores.
■​ Implementar verificações de senhas fracas, como testar contra uma lista
das 10.000 piores senhas ou senhas que foram violadas.
■​ Alinhar as políticas de comprimento, complexidade e rotação de senhas
com as diretrizes do NIST 800-63B, seção 5.1.1, ou outras diretrizes
modernas.17
■​ Proteger contra ataques automatizados (e.g., credential stuffing, brute
force) limitando ou atrasando tentativas de login falhas. Todas as falhas
devem ser registradas e monitoradas.17
■​ Usar um gerenciador de sessão seguro, do lado do servidor, que gere
novos tokens de sessão aleatórios com alta entropia após o login. Os
tokens de sessão não devem estar na URL, devem ser armazenados de
forma segura e invalidados após o logout, ociosiade e timeouts
absolutos.18
8.​ A08:2021-Software and Data Integrity Failures (Falhas de Integridade de
Software e Dados): Uma nova categoria que foca em fazer suposições
relacionadas a atualizações de software, dados críticos e pipelines de CI/CD sem
verificar a integridade. A categoria A8:2017-Insecure Deserialization agora faz
parte desta categoria maior.4
○​ O que é: Código e infraestrutura que não protegem contra violações de
integridade. Isso pode ocorrer quando uma aplicação depende de plugins,
bibliotecas ou módulos de fontes, repositórios e redes de distribuição de
conteúdo (CDNs) não confiáveis. Também inclui a desserialização insegura de
dados, onde objetos ou dados não confiáveis são desserializados, podendo
levar à execução remota de código ou outros impactos.
○​ Como é explorado: Inclusão de código malicioso através de atualizações de
software não verificadas, modificação de dados em trânsito em pipelines de
CI/CD, ou exploração de vulnerabilidades de desserialização insegura
enviando objetos serializados maliciosos.
○​ Mitigações:■​ Usar assinaturas digitais ou mecanismos similares para verificar se o
software ou dado é de uma fonte esperada e não foi alterado.
■​ Garantir que bibliotecas e dependências, como npm ou Maven, estejam
consumindo apenas de repositórios confiáveis. Se hospedar um
repositório interno, proteger o fluxo de pacotes com controles de
integridade.
■​ Garantir que haja um processo de revisão para mudanças de código e
configuração para minimizar a chance de código malicioso ser introduzido
no pipeline.
■​ Garantir que o pipeline de CI/CD tenha a configuração de segurança
adequada para proteger contra modificações não autorizadas.
■​ Para desserialização insegura: Implementar verificações de integridade ou
usar assinaturas digitais para garantir que os dados serializados não
foram adulterados. Evitar a desserialização de dados de fontes não
confiáveis ou usar tipos de dados primitivos ou formatos de dados
simples como JSON, se possível.
9.​ A09:2021-Security Logging and Monitoring Failures (Falhas de Logging e
Monitoramento de Segurança): Anteriormente A10:2017-Insufficient Logging &
Monitoring, esta categoria subiu de posição e foi expandida.4
○​ O que é: Logging e monitoramento insuficientes, juntamente com a falta de
integração com a resposta a incidentes, permitem que os atacantes
persistam em sistemas, mantenham a persistência, pivotem para mais
sistemas e adulterem, extraiam ou destruam dados.
○​ Como é explorado: Atacantes exploram a falta de logging ou monitoramento
para realizar suas atividades sem serem detectados por longos períodos,
dificultando a resposta a incidentes e a análise forense.
○​ Mitigações:
■​ Garantir que todos os eventos de login, falhas de controle de acesso e
falhas de validação de entrada do lado do servidor sejam registrados com
contexto suficiente para identificar contas suspeitas ou maliciosas, e
mantidos por um período que permita análise forense.12
■​ Garantir que os logs sejam gerados em um formato que possa ser
facilmente consumido por soluções centralizadas de gerenciamento de
logs.
■​ Garantir que transações de alto valor tenham uma trilha de auditoria com
controles de integridade para prevenir adulteração ou exclusão.
■​ Estabelecer monitoramento e alertas eficazes para que atividades
suspeitas sejam detectadas e respondidas em tempo hábil.
■​ Estabelecer ou adotar um plano de resposta a incidentes e recuperação.10.​A10:2021-Server-Side Request Forgery (SSRF) (Falsificação de Solicitação
do Lado do Servidor): Esta categoria foi adicionada com base na pesquisa da
comunidade, indicando sua crescente importância.4
○​ O que é: Falhas de SSRF ocorrem quando uma aplicação web busca um
recurso remoto sem validar a URL fornecida pelo usuário. Isso permite que um
atacante coaja a aplicação a enviar uma requisição criada para um destino
inesperado, mesmo quando protegida por um firewall, VPN ou outro tipo de
lista de controle de acesso à rede (ACL).12
○​ Como é explorado: O atacante fornece uma URL maliciosa que faz com que
o servidor se conecte a serviços internos na infraestrutura da organização ou
a recursos externos sob o controle do atacante. Isso pode ser usado para
varredura de portas internas, exposição de dados sensíveis (e.g., metadados
de instâncias de nuvem), ou para atacar serviços internos.12
○​ Mitigações:
■​ Do lado da Rede:
■​ Segmentar a funcionalidade de acesso a recursos remotos em redes
separadas para reduzir o impacto de SSRF.
■​ Aplicar políticas de firewall de "negação por padrão" ou regras de
controle de tráfego de rede para bloquear todo o tráfego de intranet,
exceto o essencial.
■​ Do lado da Aplicação:
■​ Sanitizar e validar todos os dados de entrada fornecidos pelo cliente.12
■​ Aplicar uma lista de permissão (allow list) de URLs, desabilitando o
schema file://, desabilitando redirecionamentos HTTP e sendo
cauteloso com a consistência da validação de URL para evitar ataques
como "time-of-check, time-of-use" (TOCTOU) ou condições de
corrida.
■​ Não enviar respostas brutas aos clientes.12
2.2. Relevância do OWASP Top 10 para a Segurança da Rede Atous
O OWASP Top 10 é diretamente relevante para a Rede Atous, pois muitos de seus
componentes, como a API REST para submissão de tarefas ou gerenciamento de nós,
e a própria comunicação P2P (que pode ter elementos de aplicação web), estão
sujeitos a essas vulnerabilidades. Por exemplo:
●​ Controle de Acesso Quebrado (A01): Crítico para garantir que apenas nós
autorizados possam submeter tarefas, validar blocos ou acessar dados sensíveis
na rede Atous.
●​ Falhas Criptográficas (A02): A Atous utiliza PQC extensivamente.1 Garantir acorreta implementação e gerenciamento dessas primitivas criptográficas é vital
para proteger dados de tarefas, chaves de nós e comunicações.
●​ Injeção (A03): Entradas de API, parâmetros de tarefas ou mesmo mensagens
P2P malformadas poderiam ser vetores de injeção se não forem devidamente
validadas e sanitizadas.
●​ Design Inseguro (A04): A arquitetura complexa da Atous, com múltiplos
componentes interagindo (P2P, blockchain, ABISS, agendador), requer um design
de segurança robusto desde o início para evitar falhas sistêmicas.
●​ Configuração Incorreta de Segurança (A05): Cada nó Atous, servidor de
banco de dados (MySQL, Redis), broker Kafka, deve ser configurado
corretamente para evitar exposições.
●​ Componentes Vulneráveis e Desatualizados (A06): A Atous dependerá de
bibliotecas Java, Spring, Bouncy Castle, etc. Manter essas dependências
atualizadas é crucial.
●​ Falhas de Identificação e Autenticação (A07): A autenticação de nós na rede
P2P e de usuários na API deve ser robusta.
●​ Falhas de Integridade de Software e Dados (A08): A integridade dos dados da
blockchain, das definições de tarefas e do próprio software dos nós Atous deve
ser garantida.
●​ Falhas de Logging e Monitoramento de Segurança (A09): Essencial para o
funcionamento do ABISS/NIS e para a detecção e resposta a incidentes na rede
Atous.
●​ Server-Side Request Forgery (SSRF) (A10): Se os nós Atous interagem com
URLs fornecidas externamente (e.g., para buscar dados para uma tarefa), eles
podem ser vulneráveis a SSRF.
A aplicação dos princípios e mitigações do OWASP Top 10 em todo o ciclo de vida de
desenvolvimento da Atous é um passo fundamental para alcançar a "rede
impenetrável" desejada.
Seção 3: Padrões e Guias de Segurança OWASP Adicionais
Além do Top 10, o OWASP oferece outros recursos valiosos que são cruciais para
construir e manter aplicações seguras. Para a Rede Atous, o Application Security
Verification Standard (ASVS) e a Cheat Sheet Series são particularmente relevantes.
3.1. OWASP Application Security Verification Standard (ASVS)
O OWASP ASVS é um padrão aberto que estabelece a cobertura e o nível de rigor
esperados ao realizar a verificação de segurança de aplicações web.5 Ele serve como
uma base para testar controles de segurança técnica e pode ser usado para definirrequisitos de segurança em contratos.6
●​ Estrutura e Níveis: O ASVS é dividido em várias seções (e.g., V1 Arquitetura,
Design e Modelagem de Ameaças; V2 Autenticação; V4 Controle de Acesso; V6
Criptografia Armazenada; V13 API e Web Service).5 Ele define três níveis de
verificação de segurança (Níveis 1, 2 e 3), onde o Nível 1 representa uma linha de
base para todas as aplicações, o Nível 2 é para aplicações que contêm dados
sensíveis e é o nível recomendado para a maioria das aplicações, e o Nível 3 é
para aplicações críticas que exigem o mais alto nível de confiança (e.g., aquelas
que lidam com transações de alto valor ou dados médicos sensíveis).5 Dada a
natureza da Rede Atous e seus objetivos de segurança, aspirar ao Nível 2 ou
mesmo ao Nível 3 do ASVS para seus componentes críticos seria apropriado.
●​ Como Usar: O ASVS pode ser usado como um guia para desenvolvedores,
arquitetos e testadores de segurança. Ele fornece uma lista detalhada de
requisitos de verificação (286 na versão 4.0.3) que podem ser usados para:
○​ Definir requisitos de segurança durante a fase de design.
○​ Orientar o desenvolvimento de código seguro.
○​ Servir como um checklist para testes de segurança manuais e automatizados.
○​ Auxiliar na seleção de ferramentas de segurança.
●​ Relevância para Atous: Para a Rede Atous, o ASVS pode ser usado para:
○​ V1 (Arquitetura, Design e Modelagem de Ameaças): Garantir que a
arquitetura da Atous (Clean Architecture, P2P, blockchain, ABISS) seja
projetada com a segurança em mente, incluindo a modelagem de ameaças
para identificar potenciais fraquezas.5
○​ V2 (Autenticação) e V3 (Gerenciamento de Sessão): Verificar a robustez
dos mecanismos de autenticação de nós e usuários, e o gerenciamento de
tokens de sessão (e.g., JWTs PQC-híbridos).5
○​ V4 (Controle de Acesso): Garantir que os controles de acesso para
funcionalidades da API, operações na blockchain e interações P2P sejam
corretamente implementados.5
○​ V5 (Validação, Sanitização e Codificação): Verificar se todas as entradas
(API, P2P, parâmetros de tarefas) são devidamente validadas e sanitizadas
para prevenir injeções.5
○​ V6 (Criptografia Armazenada): Avaliar como as chaves PQC e outros dados
criptográficos sensíveis são armazenados e gerenciados.5
○​ V9 (Comunicação): Verificar a segurança dos canais de comunicação
(TLS/mTLS com PQC) entre os nós Atous e com os armazenamentos de
dados.5
○​ V13 (API e Web Service): Aplicar verificações específicas para a segurançada API REST da Atous.5
3.2. OWASP Cheat Sheet Series (CSS)
A OWASP Cheat Sheet Series (CSS) foi criada para fornecer um conjunto de guias de
boas práticas simples e acionáveis para desenvolvedores e defensores de
aplicações.3 Em vez de focar em melhores práticas detalhadas que podem ser
impraticáveis para muitos, as cheat sheets visam fornecer boas práticas que a maioria
dos desenvolvedores será capaz de implementar.3
●​ Objetivo: As cheat sheets cobrem uma ampla gama de tópicos de segurança,
oferecendo conselhos práticos e exemplos de código. Elas servem como
referências rápidas para ajudar os desenvolvedores a evitar erros comuns de
segurança.
●​ Tópicos Relevantes para Atous:
○​ Authentication Cheat Sheet: Orientações sobre IDs de usuário, políticas de
senha, proteção de credenciais, MFA, tratamento de erros de login e
logging.17 Para a Atous, isso é crucial para a autenticação de nós e usuários
da API.
○​ Authorization Cheat Sheet (anteriormente Access Control Cheat Sheet):
Descreve diferentes modelos de controle de acesso (RBAC, DAC, MAC) e
melhores práticas para sua implementação.13 Fundamental para definir e
impor o que cada nó/usuário pode fazer na Rede Atous.
○​ Input Validation Cheat Sheet: Detalha a importância da validação de todas
as entradas e como fazê-lo de forma eficaz para prevenir vários tipos de
ataques de injeção. Aplicável a todas as interfaces de entrada da Atous (API,
P2P, parâmetros de tarefas).
○​ Cross-Site Scripting (XSS) Prevention Cheat Sheet: Foca em como
prevenir XSS através de codificação de saída apropriada e uso de Content
Security Policy. Relevante se a Atous tiver interfaces web ou retornar
conteúdo que possa ser interpretado por navegadores.
○​ SQL Injection Prevention Cheat Sheet: Embora a Atous use JPA 1, que
geralmente protege contra SQLi através de consultas parametrizadas,
entender os princípios é importante, especialmente se houver queries nativas
ou construídas dinamicamente.
○​ REST Security Cheat Sheet: Cobre segurança para APIs REST, incluindo uso
de HTTPS, controle de acesso, JWTs, chaves de API, restrição de métodos
HTTP, validação de entrada e tipos de conteúdo, tratamento de erros, logs de
auditoria e cabeçalhos de segurança.16 Diretamente aplicável à API REST da
Atous.○​ JSON Web Token (JWT) for Java Cheat Sheet: Fornece dicas específicas
para prevenir problemas comuns de segurança ao usar JWTs em Java, como
o algoritmo "none", token sidejacking, revogação de tokens, divulgação de
informações e armazenamento seguro no cliente.16 Essencial para a
implementação de autenticação baseada em token na Atous.
○​ Threat Modeling Cheat Sheet: Oferece um guia prático sobre como realizar
modelagem de ameaças, respondendo a perguntas como "No que estamos
trabalhando?", "O que pode dar errado?", "O que vamos fazer a respeito?" e
"Fizemos um trabalho bom o suficiente?".11 A modelagem de ameaças deve
ser uma atividade contínua para a Rede Atous.
○​ Logging Cheat Sheet: Orienta sobre quais eventos registrar, que dados
incluir nos logs e como proteger os logs. Crucial para o monitoramento de
segurança e para o sistema ABISS/NIS.
A utilização combinada do ASVS para definir um padrão de verificação e da Cheat
Sheet Series para orientação prática no desenvolvimento pode elevar
significativamente o nível de segurança da Rede Atous.
Seção 4: Metodologias de Teste de Penetração (Pentest) em
Aplicações
Testes de penetração (pentests) são simulações autorizadas de ciberataques em um
sistema de computador, realizadas para avaliar a segurança do sistema. O objetivo
principal é identificar vulnerabilidades de segurança, avaliar sua gravidade e fornecer
recomendações para mitigá-las. Para a Rede Atous, uma estratégia de pentesting
abrangente é essencial para validar sua meta de ser uma "rede impenetrável". Existem
várias metodologias e tipos de testes de segurança de aplicações, incluindo SAST,
DAST, IAST e SCA.
4.1. SAST (Static Application Security Testing)
●​ O que é: SAST, ou teste estático de segurança de aplicações, analisa o
código-fonte, bytecode ou código binário de uma aplicação em busca de
vulnerabilidades de segurança sem executar o código.19 É uma abordagem de
"caixa branca", onde o testador tem acesso ao funcionamento interno da
aplicação.
●​ Como funciona: Ferramentas SAST escaneiam o código em busca de padrões
que indicam possíveis vulnerabilidades, como falhas de injeção SQL, cross-site
scripting, buffer overflows, e configurações inseguras. Elas constroem um modelo
do código e do fluxo de dados para identificar caminhos que podem levar a umaexploração.
●​ Prós:
○​ Pode ser integrado no início do ciclo de vida de desenvolvimento (SDLC),
permitindo que as vulnerabilidades sejam encontradas e corrigidas mais
cedo, o que é geralmente mais barato ("shift left").20
○​ Fornece cobertura completa do código, incluindo partes que podem não ser
facilmente acessíveis através de testes dinâmicos.
○​ Ajuda a identificar falhas de codificação e design.
●​ Contras:
○​ Pode gerar um número significativo de falsos positivos, exigindo tempo para
triagem.20
○​ Não consegue encontrar vulnerabilidades de tempo de execução que
dependem do ambiente de implantação ou da interação com outros sistemas.
○​ Pode ter dificuldade em analisar aplicações complexas com muitas
dependências ou código dinâmico.
●​ Ferramentas para Java (Atous):
○​ SonarQube: Uma plataforma popular para inspeção contínua da qualidade
do código, que inclui funcionalidades SAST para detectar vulnerabilidades,
bugs e "code smells".21 Suporta Java e se integra bem com Maven.
○​ Snyk Code: Parte da plataforma Snyk, foca em segurança para
desenvolvedores e oferece SAST com o objetivo de ser rápido e preciso, com
boa integração em IDEs.22
○​ Outras ferramentas comerciais e de código aberto.
●​ Relevância para Atous: SAST será valioso para analisar o código Java da Atous
(módulos core-domain, application, infrastructure 1) em busca de falhas de
codificação segura, especialmente em áreas críticas como manipulação de
entrada, lógica de controle de acesso e implementação de PQC.
4.2. DAST (Dynamic Application Security Testing)
●​ O que é: DAST, ou teste dinâmico de segurança de aplicações, analisa uma
aplicação em seu estado de execução.19 É uma abordagem de "caixa preta", onde
o testador não tem conhecimento do funcionamento interno da aplicação e a
testa da perspectiva de um atacante externo.
●​ Como funciona: Ferramentas DAST enviam uma variedade de entradas
maliciosas e payloads de ataque para a aplicação em execução e observam as
respostas para identificar vulnerabilidades. Elas simulam ataques comuns como
SQL injection, XSS, command injection, path traversal, etc..23
●​ Prós:
○​ Encontra vulnerabilidades de tempo de execução que o SAST pode perder,incluindo problemas de configuração do servidor e falhas de interação entre
componentes.
○​ Geralmente tem menos falsos positivos do que o SAST, pois as
vulnerabilidades são confirmadas através de exploração real (ou tentativa).
○​ Não requer acesso ao código-fonte.
●​ Contras:
○​ Só pode encontrar vulnerabilidades em partes da aplicação que são
executadas durante o teste. A cobertura do código pode ser limitada.
○​ Não identifica a localização exata da vulnerabilidade no código-fonte, o que
pode dificultar a correção.
○​ Os testes podem ser mais lentos, pois envolvem a execução da aplicação.
●​ Ferramentas para Atous:
○​ OWASP ZAP (Zed Attack Proxy): Uma ferramenta DAST de código aberto
amplamente utilizada e poderosa, com funcionalidades de varredura ativa,
passiva, spidering e scripting.7 Ideal para testar as APIs REST da Atous.
○​ Outras ferramentas comerciais e de código aberto.
●​ Relevância para Atous: DAST é crucial para testar as APIs REST expostas pela
Atous, a interface de comunicação P2P (se ela responder a certos tipos de
"requisições" externas) e qualquer interface web de gerenciamento. A automação
de scans DAST com ZAP (ver Seção 6) será uma parte importante da estratégia
de testes.
4.3. IAST (Interactive Application Security Testing)
●​ O que é: IAST, ou teste interativo de segurança de aplicações, combina
elementos de SAST e DAST. Ele funciona instrumentando a aplicação em
execução com agentes que monitoram o fluxo de dados e a lógica de execução
de dentro da aplicação enquanto ela é testada (geralmente por testes funcionais
automatizados ou um scanner DAST).20
●​ Como funciona: Os agentes IAST analisam o comportamento da aplicação em
tempo de execução, rastreando como as entradas do usuário fluem através do
código e identificando quando essas entradas atingem "sinks" perigosos (e.g.,
uma query SQL) sem a devida sanitização.
●​ Prós:
○​ Maior precisão e menos falsos positivos do que SAST, pois analisa o
comportamento real do código em execução.20
○​ Pode identificar a linha exata de código vulnerável, como o SAST, facilitando a
correção.
○​ Boa cobertura, pois analisa o código que é realmente executado durante os
testes.○​ Pode detectar uma ampla gama de vulnerabilidades, incluindo aquelas que
dependem do fluxo de dados e da lógica de negócios.20
●​ Contras:
○​ Requer instrumentação da aplicação, o que pode adicionar algum overhead
de desempenho durante os testes.20
○​ Pode exigir mais configuração inicial e integração em ambientes de teste do
que SAST ou DAST puros.20
○​ A cobertura ainda depende da abrangência dos testes funcionais ou DAST
que exercitam a aplicação.
●​ Ferramentas: Geralmente são soluções comerciais.
●​ Relevância para Atous: Se o orçamento e a infraestrutura permitirem, IAST
poderia fornecer uma camada adicional de segurança para a Atous,
especialmente para validar a segurança da lógica de negócios complexa nos
UseCases e a interação entre os diferentes módulos durante a execução.
4.4. SCA (Software Composition Analysis)
●​ O que é: SCA, ou análise de composição de software, foca na identificação de
todos os componentes de software de código aberto e de terceiros em uma
aplicação e na detecção de quaisquer vulnerabilidades de segurança conhecidas
ou problemas de licenciamento associados a esses componentes.19
●​ Como funciona: Ferramentas SCA escaneiam as dependências do projeto (e.g.,
arquivos pom.xml para Maven), identificam os componentes e suas versões, e os
comparam com bancos de dados de vulnerabilidades conhecidas (como a
National Vulnerability Database - NVD) e informações de licença.
●​ Prós:
○​ Aborda o risco A06:2021-Vulnerable and Outdated Components do OWASP
Top 10.12
○​ Automatiza o processo de rastreamento de dependências e suas
vulnerabilidades.
○​ Ajuda a garantir a conformidade com as licenças de software.
●​ Contras:
○​ A eficácia depende da abrangência e da atualidade dos bancos de dados de
vulnerabilidades.
○​ Pode gerar falsos positivos ou alertas para vulnerabilidades em partes não
utilizadas de uma dependência.
●​ Ferramentas para Atous:
○​ OWASP Dependency-Check: Uma ferramenta SCA de código aberto que
pode ser integrada em builds Maven.9
○​ Snyk Open Source: Parte da plataforma Snyk, especializada na detecção devulnerabilidades em dependências de código aberto.21
○​ Outras ferramentas comerciais.
●​ Relevância para Atous: Sendo um projeto Java com Spring e outras bibliotecas
(Bouncy Castle, Kafka clients, Redis clients, etc.) 1, a Atous terá muitas
dependências. SCA é essencial para gerenciar os riscos associados a esses
componentes de terceiros. A integração do dependency-check-maven-plugin
(ver Seção 6) no pipeline de CI/CD é uma recomendação chave.
A combinação dessas metodologias (SAST para análise de código estático, DAST para
testes em tempo de execução, IAST para uma visão interativa e SCA para
gerenciamento de dependências) fornece uma abordagem de segurança em
camadas, ajudando a Rede Atous a se aproximar de seu objetivo de "tolerância zero a
falhas".
Seção 5: OWASP ZAP (Zed Attack Proxy) para Testes de API na
Atous
O OWASP ZAP é uma das ferramentas de teste de segurança de aplicações web mais
populares e poderosas do mundo, gratuita e de código aberto.7 Ele pode ajudar a
encontrar automaticamente vulnerabilidades de segurança em aplicações web
durante as fases de desenvolvimento e teste, bem como auxiliar em testes de
penetração manuais.8 Para a Rede Atous, o ZAP é particularmente útil para testar a
segurança de suas APIs REST.
5.1. Introdução ao OWASP ZAP e seus Modos de Operação
O ZAP funciona como um proxy "man-in-the-middle", interceptando o tráfego entre o
navegador (ou cliente de API) e a aplicação web. Ele pode então inspecionar,
modificar e reenviar esse tráfego para testar vulnerabilidades.
Principais modos e funcionalidades do ZAP:
●​ Proxy Passivo (Passive Scanning): O ZAP observa passivamente o tráfego
HTTP/S que passa por ele e analisa as requisições e respostas em busca de
potenciais vulnerabilidades (e.g., falta de cabeçalhos de segurança, exposição de
informações sensíveis em comentários HTML). Não envia tráfego malicioso.
●​ Spidering (Tradicional e AJAX):
○​ Spider Tradicional: Rastreia links HTML para descobrir o conteúdo e a
estrutura de uma aplicação web.
○​ AJAX Spider: Para aplicações web modernas que usam muito JavaScript
(e.g., Single Page Applications - SPAs), o AJAX Spider inicia navegadores e osdireciona para rastrear a aplicação, descobrindo links e funcionalidades que o
spider tradicional poderia perder.
●​ Varredura Ativa (Active Scanning): O ZAP envia uma série de ataques
conhecidos para os parâmetros e funcionalidades descobertos da aplicação para
encontrar vulnerabilidades como SQL Injection, XSS, Command Injection, Path
Traversal, etc. Este modo é intrusivo e deve ser usado com cautela em ambientes
de produção.
●​ API ZAP: O ZAP expõe uma API rica que permite que quase todas as suas
funcionalidades sejam controladas programaticamente, facilitando a automação
e a integração em pipelines de CI/CD.7
●​ Scripts: O ZAP suporta scripts em várias linguagens (e.g., JavaScript, Python,
Zest) para estender sua funcionalidade, como scripts de autenticação, scripts
que modificam requisições/respostas (HTTP Sender scripts), ou scripts para
varreduras ativas/passivas customizadas.25
●​ Add-ons: O ZAP possui um marketplace de add-ons que estendem suas
capacidades, incluindo suporte para diferentes tecnologias, novas regras de
varredura e integrações.25
5.2. Configurando o ZAP para Escanear APIs REST (OpenAPI/Swagger)
Para APIs REST, como as que a Rede Atous provavelmente exporá para submissão de
tarefas ou gerenciamento de nós 1, o ZAP pode importar definições de API (e.g.,
OpenAPI/Swagger) para entender melhor os endpoints disponíveis e seus parâmetros.
Passos para configurar o ZAP para escanear uma API REST da Atous:
1.​ Obter a Definição da API: A API REST da Atous deve expor sua definição no
formato OpenAPI (v2 ou v3), geralmente como um arquivo JSON ou YAML (e.g.,
/v3/api-docs em aplicações Spring Boot com Springdoc).
2.​ Iniciar o ZAP: Pode ser a versão desktop ou via Docker.
3.​ Importar a Definição da API:
○​ Via UI do ZAP Desktop:
■​ Ir em Import -> Import an OpenAPI definition from a local file ou Import an
OpenAPI definition from a URL.26
■​ Fornecer o caminho para o arquivo ou a URL da definição OpenAPI da
Atous.
■​ O ZAP irá parsear a definição e adicionar os endpoints descobertos à
árvore de Sites.
○​ Via API ZAP:
■​ Usar o endpoint da API ZAP openapi/action/importFile ou
openapi/action/importUrl.254.​ Configurar o Contexto:
○​ Um "Contexto" no ZAP define o escopo da aplicação que está sendo testada.
É crucial configurar um contexto para a API Atous.
○​ Incluir os URLs base da API Atous no contexto.
○​ Autenticação: Este é um passo crítico. Se a API Atous usa autenticação (e.g.,
tokens JWT PQC-híbridos 1), o ZAP precisa ser configurado para lidar com
isso:
■​ Para Autenticação Baseada em Token (e.g., Bearer Token JWT):
■​ Obtenção do Token: O token pode ser obtido manualmente (e.g., via
uma requisição de login separada) e configurado no ZAP, ou o ZAP
pode ser configurado com um script de autenticação que lida com o
login e a extração/atualização do token.
■​ Injeção do Token:
■​ Variáveis de Ambiente (Docker): Ao usar os scripts
empacotados do ZAP em Docker (como zap-api-scan.py),
pode-se usar a variável de ambiente ZAP_AUTH_HEADER_VALUE
para definir o valor do cabeçalho de autorização (e.g.,
ZAP_AUTH_HEADER_VALUE="Bearer
<SEU_TOKEN_ATOUS_AQUI>").23 Outras variáveis como
ZAP_AUTH_HEADER e ZAP_AUTH_HEADER_SITE podem ser usadas
para customizar o nome do cabeçalho e o site ao qual ele se
aplica.23
■​ Scripts HTTP Sender: Criar um script (e.g., JavaScript) que
intercepta todas as requisições enviadas pelo ZAP para o contexto
da API Atous e adiciona/atualiza o cabeçalho Authorization com o
token JWT válido.
■​ Replacers: Usar as regras de "Replacer" do ZAP para adicionar ou
modificar cabeçalhos. Isso pode ser configurado via UI ou API ZAP,
ou através de opções de linha de comando para os scripts de scan
(-z "-config replacer...").27
■​ Scan Hooks (para zap-api-scan.py): Um arquivo de "hook"
Python pode ser usado com zap-api-scan.py para executar
código Python em certos pontos do scan.28 Um hook zap_started
poderia, teoricamente, obter um token e tentar configurar o ZAP
via sua API para usá-lo, embora a passagem direta do token via
variáveis de ambiente ou opções -z seja geralmente mais simples
para os scripts de scan empacotados.25
5.​ Spidering (Opcional, mas Recomendado para APIs):
○​ Mesmo com uma definição OpenAPI, o spidering (especialmente o AJAXspider se houver componentes de UI associados à API) pode ajudar a
descobrir endpoints ou parâmetros não documentados. Para APIs puras, o
spidering tradicional após a importação da definição pode ser suficiente. O
script zap-api-scan.py realiza um spider tradicional por padrão após importar
a definição.
6.​ Varredura Ativa:
○​ Uma vez que os endpoints e parâmetros são conhecidos (via importação
OpenAPI e/ou spidering), executar uma varredura ativa.
○​ O ZAP usará várias técnicas de ataque para testar as vulnerabilidades nos
endpoints da API Atous.
○​ É importante configurar uma política de varredura (Scan Policy) apropriada
para APIs. O script zap-api-scan.py usa uma política ajustada para APIs,
desabilitando regras focadas em cliente (como XSS DOM) e adicionando
algumas específicas para APIs (e.g., erros de código de resposta HTTP, tipos
de conteúdo inesperados).27
5.3. Automatizando Scans de API com zap-api-scan.py
O script zap-api-scan.py é fornecido nas imagens Docker do ZAP e é projetado para
facilitar a automação de scans de API.27
Comando Básico para zap-api-scan.py (via Docker):
Bash
#!/bin/bash​
​
# URL da definição OpenAPI da API Atous (ajustar conforme necessário)​
ATOUS_OPENAPI_URL="http://<HOST_ATOUS_API>:<PORTA>/v3/api-docs"​
# Ou um arquivo local: ATOUS_OPENAPI_URL="/path/to/atous-openapi.json"​
​
# Diretório para salvar relatórios​
REPORT_DIR="$(pwd)/zap_reports_atous_api"​
mkdir -p "$REPORT_DIR"​
chmod 777 "$REPORT_DIR" # Para permissão de escrita do container Docker​
​
# Nome base para os relatórios​
TIMESTAMP=$(date +"%Y%m%d_%H%M%S")​
REPORT_NAME_BASE="Atous_API_Scan_Report_${TIMESTAMP}"​​
# --- Configuração de Autenticação (Exemplo com Bearer Token Estático) ---​
# Obter o token JWT da Atous (substituir pelo método real de obtenção)​
# Em um pipeline CI/CD, este token seria obtido de forma segura (e.g., de um vault ou como um
segredo CI)​
# Para este exemplo, vamos supor que o token é passado como uma variável de ambiente​
# export ATOUS_JWT_TOKEN="seu_token_jwt_aqui"​
​
ZAP_AUTH_OPTIONS=""​
if; then​
echo "Token JWT da Atous encontrado. Configurando autenticação para o ZAP."​
# Usando a variável de ambiente ZAP_AUTH_HEADER_VALUE para o Docker​
# Esta variável é lida pelo script zap-api-scan.py ou pelo ZAP internamente​
# para adicionar o cabeçalho a todas as requisições.​
ZAP_AUTH_OPTIONS="-e ZAP_AUTH_HEADER_VALUE=\"Bearer ${ATOUS_JWT_TOKEN}\""​
else​
echo "Nenhum token JWT da Atous fornecido. O scan prosseguirá sem autenticação."​
fi​
​
# --- Execução do Scan ---​
echo "Iniciando OWASP ZAP API Scan em: $ATOUS_OPENAPI_URL"​
echo "Relatórios serão salvos em: $REPORT_DIR"​
​
# Comando Docker para executar o ZAP API Scan​
# -t: URL da definição da API (OpenAPI)​
# -f: Formato da definição (openapi)​
# -r: Nome do arquivo de relatório HTML​
# -x: Nome do arquivo de relatório XML​
# -J: Nome do arquivo de relatório JSON​
# -d: Modo debug para mais informações do script​
# --hook: Para carregar um arquivo de hooks Python (opcional)​
# -z: Para passar opções de linha de comando diretamente para o ZAP (opcional)​
​
docker run --rm \​
-v "$REPORT_DIR":/zap/wrk/:rw \​
$ZAP_AUTH_OPTIONS \​
-t ghcr.io/zaproxy/zaproxy:stable \​
zap-api-scan.py \​
-t "$ATOUS_OPENAPI_URL" \​
-f openapi \​
-r "${REPORT_NAME_BASE}.html" \​
-x "${REPORT_NAME_BASE}.xml" \​-J "${REPORT_NAME_BASE}.json" \​
-d # Modo debug​
​
# Verificar se os relatórios foram gerados​
if; then​
echo "Scan da API Atous concluído. Relatório HTML: $REPORT_DIR/${REPORT_NAME_BASE}.html"​
else​
echo "Erro: Scan da API Atous do ZAP falhou ou não gerou relatórios."​
exit 1​
fi​
​
# Adicionar lógica para falhar o pipeline CI/CD com base nos resultados do ZAP​
# Exemplo: Verificar se há alertas de risco Alto no relatório XML/JSON​
# (requer jq para JSON ou xmlstarlet para XML)​
# HIGH_ALERTS=$(jq '.site.alerts | select(.riskcode == "3") | length'
"$REPORT_DIR/${REPORT_NAME_BASE}.json" | wc -l)​
# if; then​
# echo "ALERTA: $HIGH_ALERTS vulnerabilidades de risco ALTO encontradas pelo ZAP na API Atous!"​
# exit 1 # Falha o build​
# fi​
​
echo "Análise de segurança da API Atous com ZAP finalizada."​
exit 0​
Explicação do Script Bash:
1.​ ATOUS_OPENAPI_URL: Define a localização da especificação OpenAPI da API
Atous. Pode ser uma URL ou um caminho de arquivo local (se o arquivo for
montado no container Docker).
2.​ REPORT_DIR e REPORT_NAME_BASE: Configuram onde os relatórios do ZAP
serão salvos e seus nomes base, incluindo um timestamp.
3.​ Configuração de Autenticação (ZAP_AUTH_OPTIONS):
○​ Este exemplo demonstra como passar um token Bearer JWT estático para o
container Docker do ZAP usando a variável de ambiente
ZAP_AUTH_HEADER_VALUE. O script zap-api-scan.py (ou o ZAP subjacente)
usa essa variável para adicionar automaticamente o cabeçalho Authorization:
Bearer <token> a todas as requisições que ele faz durante o scan.23
○​ Em um cenário real de CI/CD, ATOUS_JWT_TOKEN deve ser obtido de forma
segura (e.g., secrets do CI, vault) e não hardcoded.
○​ Se o token precisar ser obtido dinamicamente ou renovado durante o scan,
uma abordagem mais sofisticada usando scripts de autenticação do ZAP ou
hooks mais complexos seria necessária.4.​ Comando docker run:
○​ --rm: Remove o container após a execução.
○​ -v "$REPORT_DIR":/zap/wrk/:rw: Monta o diretório de relatórios do host no
diretório de trabalho /zap/wrk/ dentro do container, permitindo que o ZAP
salve os relatórios lá.
○​ $ZAP_AUTH_OPTIONS: Passa as opções de autenticação (a variável de
ambiente ZAP_AUTH_HEADER_VALUE) para o container.
○​ -t ghcr.io/zaproxy/zaproxy:stable: Especifica a imagem Docker do ZAP a ser
usada (recomenda-se usar a stable ou uma versão específica).
○​ zap-api-scan.py: O script Python dentro da imagem Docker que orquestra o
scan.
○​ -t "$ATOUS_OPENAPI_URL": Especifica o alvo da definição da API.
○​ -f openapi: Indica que o formato da definição é OpenAPI.
○​ -r, -x, -J: Especificam os nomes dos arquivos para os relatórios HTML, XML e
JSON, respectivamente.
○​ -d: Habilita o modo de depuração para o script, fornecendo mais informações
no log.
5.​ Verificação de Relatório e CI/CD: O script verifica se o relatório HTML foi
gerado e inclui um exemplo comentado de como se poderia analisar o relatório
JSON (usando jq) para falhar um build CI/CD se vulnerabilidades de alto risco
forem encontradas.
Scan Hooks com zap-api-scan.py (--hook):
O zap-api-scan.py permite o uso de "scan hooks", que são scripts Python que podem
modificar o comportamento do scan em vários pontos.28 Um arquivo de hook pode ser
especificado com a opção --hook=/zap/wrk/my-hooks.py (assumindo que
my-hooks.py está montado no diretório /zap/wrk/).
Exemplo de my-hooks.py para Autenticação (Conceitual):
Python
# my-hooks.py​
import requests​
import json​
import os​​
# Assume que as credenciais são passadas como variáveis de ambiente​
# ou obtidas de um vault de forma segura em um pipeline CI/CD​
ATOUS_API_USER = os.getenv('ATOUS_API_USER_FOR_ZAP')​
ATOUS_API_PASSWORD = os.getenv('ATOUS_API_PASSWORD_FOR_ZAP')​
ATOUS_AUTH_URL = os.getenv('ATOUS_AUTH_URL_FOR_ZAP',
'http://localhost:8080/api/v1/auth/login') # Exemplo de URL da API Atous​
​
# Variável global para armazenar o token dentro do escopo do hook​
atous_bearer_token = None​
​
def get_atous_token_once():​
"""Obtém o token da API Atous apenas uma vez."""​
global atous_bearer_token​
if atous_bearer_token:​
return atous_bearer_token​
​
if not ATOUS_API_USER or not ATOUS_API_PASSWORD:​
print("HOOK: Credenciais da API Atous para ZAP não definidas. Pulando obtenção de token.")​
return None​
try:​
print(f"HOOK: Tentando obter token de {ATOUS_AUTH_URL} para o usuário {ATOUS_API_USER}")​
payload = {'username': ATOUS_API_USER, 'password': ATOUS_API_PASSWORD}​
# Importante: Se o ZAP estiver rodando em Docker e a API Atous estiver no host,​
# 'localhost' dentro do container ZAP não será o 'localhost' do host.​
# Use o IP do host (e.g., host.docker.internal) ou configure a rede Docker apropriadamente.​
# Para este exemplo, ATOUS_AUTH_URL deve ser acessível de dentro do container ZAP.​
response = requests.post(ATOUS_AUTH_URL, json=payload, timeout=15)​
response.raise_for_status()​
token_data = response.json()​
atous_bearer_token = token_data.get('accessToken') # Ajustar conforme a resposta real
da API Atous​
if atous_bearer_token:​
print(f"HOOK: Token da Atous obtido com sucesso: {atous_bearer_token[:20]}...") # Log
truncado​
else:​
print(f"HOOK: 'accessToken' não encontrado na resposta JSON de {ATOUS_AUTH_URL}.
Resposta: {token_data}")​
return atous_bearer_token​
except requests.exceptions.RequestException as e:​print(f"HOOK: Erro ao obter token da Atous: {e}")​
return None​
except json.JSONDecodeError as e:​
print(f"HOOK: Erro ao decodificar JSON da resposta de autenticação: {e}. Resposta:
{response.text}")​
return None​
​
# Hook executado antes do ZAP acessar o alvo pela primeira vez.​
# Pode ser usado para configurar a autenticação.​
def zap_access_target(zap, target):​
"""​
Este hook é chamado antes do ZAP acessar o alvo.​
Podemos tentar configurar o ZAP para usar um token Bearer aqui.​
"""​
print(f"HOOK: zap_access_target chamado para o alvo: {target}")​
token = get_atous_token_once()​
if token:​
print("HOOK: Configurando o ZAP para usar o token Bearer globalmente (via API ZAP)...")​
try:​
# Adiciona uma regra de substituição global para o cabeçalho Authorization.​
# Esta é uma maneira de injetar o token em todas as requisições subsequentes do ZAP.​
# Nota: O ZAP deve estar escutando na API (geralmente localhost:8080 por padrão DENTRO
do container)​
# O objeto 'zap' é uma instância de zapv2.ZAPv2 configurada para o ZAP rodando.​
​
# Remover regras de substituição existentes para 'Authorization' para evitar duplicatas​
replacer_rules = zap.replacer.rules​
for rule in replacer_rules:​
if rule.get('description') == 'Atous Auth Bearer Hook':​
print(f"HOOK: Removendo regra de substituição existente: {rule.get('description')}")​
zap.replacer.remove_rule(description='Atous Auth Bearer Hook')​
break​
​
zap.replacer.add_rule(​
description='Atous Auth Bearer Hook',​
enabled=True,​
matchtype='REQ_HEADER', # Substituir cabeçalho de requisição​
matchstr='Authorization', # Nome do cabeçalho a ser potencialmente substituído (ou
adicionado se ausente)​
replacement=f'Bearer {token}',​initiators=None # Aplicar a todos os initiators​
)​
print("HOOK: Regra de substituição para Authorization header configurada no ZAP.")​
​
# Alternativamente, se o script de autenticação do ZAP for mais adequado:​
# 1. Criar um script de autenticação (e.g., JavaScript).​
# 2. Carregar o script no ZAP via API: zap.script.load(...)​
# 3. Configurar o método de autenticação para o contexto:
zap.authentication.set_authentication_method(...)​
# 4. Adicionar um usuário para o contexto: zap.users.new_user(...)​
# 5. Configurar credenciais para o usuário: zap.users.set_authentication_credentials(...)​
# 6. Habilitar o usuário: zap.users.set_user_enabled(...)​
# 7. Forçar o usuário para o contexto: zap.forcedUser.set_forced_user(...)​
# Esta abordagem é mais robusta para tokens que expiram.​
​
except Exception as e:​
print(f"HOOK: Erro ao configurar autenticação no ZAP via API: {e}")​
else:​
print("HOOK: Não foi possível obter o token da Atous. O scan prosseguirá sem autenticação
configurada por este hook.")​
​
# Outros hooks podem ser definidos aqui, se necessário, por exemplo:​
# def zap_pre_shutdown(zap):​
# print("HOOK: ZAP está prestes a desligar.")​
​
# Nota: Para que este hook funcione efetivamente com zap-api-scan.py,​
# o objeto 'zap' (instância de ZAPv2) deve estar corretamente configurado​
# para se comunicar com a API do ZAP que está rodando dentro do container Docker.​
# O script zap-api-scan.py geralmente lida com o início e parada do ZAP.​
# A configuração de autenticação via variáveis de ambiente ZAP_AUTH_HEADER_VALUE​
# é frequentemente mais direta para tokens estáticos com esses scripts empacotados.​
Para usar este hook com o script Bash anterior:
1.​ Salve o código Python acima como atous_zap_hooks.py no mesmo diretório do
script Bash.
2.​ Modifique a linha docker run no script Bash para incluir a montagem do arquivo
de hook e a opção --hook:​
Bash​
#... (outras partes do script Bash)...​
​
docker run --rm \​-v "$REPORT_DIR":/zap/wrk/:rw \​
-v "$(pwd)/atous_zap_hooks.py":/zap/wrk/atous_zap_hooks.py:ro \​
$ZAP_AUTH_OPTIONS \​
-e ATOUS_API_USER_FOR_ZAP="$ATOUS_API_USER" \ # Passar credenciais para o hook​
-e ATOUS_API_PASSWORD_FOR_ZAP="$ATOUS_API_PASSWORD" \​
-e ATOUS_AUTH_URL_FOR_ZAP="$ATOUS_AUTH_URL_FOR_ZAP_ENDPOINT" \ # Passar
URL de auth para o hook​
-t ghcr.io/zaproxy/zaproxy:stable \​
zap-api-scan.py \​
-t "$ATOUS_OPENAPI_URL" \​
-f openapi \​
-r "${REPORT_NAME_BASE}.html" \​
-x "${REPORT_NAME_BASE}.xml" \​
-J "${REPORT_NAME_BASE}.json" \​
--hook /zap/wrk/atous_zap_hooks.py \​
-d # Modo debug​
​
#... (resto do script Bash)...​
○​ Nota Importante sobre Hooks e zap-api-scan.py: A eficácia de um hook
para configurar a autenticação globalmente para todas as requisições do
active scan iniciado pelo zap-api-scan.py pode depender de como o script
gerencia os contextos e as políticas de scan. A documentação do ZAP 28
indica que hooks como zap_active_scan(zap, target, policy) existem, onde se
poderia tentar modificar a política ou o zap (cliente da API ZAP) antes do
scan. No entanto, para autenticação persistente, usar as variáveis de
ambiente ZAP_AUTH_HEADER_VALUE ou configurar um script de autenticação
diretamente no ZAP (e acioná-lo via API no hook, se necessário) são
geralmente as abordagens mais confiáveis com os scripts empacotados. O
hook zap_access_target é chamado antes do ZAP acessar o alvo, o que pode
ser um bom momento para configurar o cabeçalho de autenticação
globalmente usando as APIs do ZAP, como a API replacer.
A automação de scans de segurança de API com ZAP, integrada em um pipeline de
CI/CD, é uma prática recomendada para identificar vulnerabilidades cedo no ciclo de
desenvolvimento, alinhando-se com os objetivos de segurança da Rede Atous.
Seção 6: OWASP Dependency-Check para Análise de
Componentes na AtousO OWASP Dependency-Check é uma ferramenta de Análise de Composição de
Software (SCA) que tenta detectar vulnerabilidades publicamente divulgadas contidas
nas dependências de um projeto.9 Para a Rede Atous, que é desenvolvida em Java
com Maven e utiliza diversas bibliotecas de terceiros (Spring, Bouncy Castle, etc. 1), o
Dependency-Check é essencial para gerenciar o risco A06:2021-Vulnerable and
Outdated Components do OWASP Top 10.12
6.1. Configurando o dependency-check-maven-plugin
O plugin dependency-check-maven pode ser integrado ao pom.xml do projeto Atous
para automatizar a verificação de dependências.
Exemplo de Configuração no pom.xml (módulo pai ou módulo bootstrap):
XML
<project xmlns="http://maven.apache.org/POM/4.0.0"​
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"​
xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
http://maven.apache.org/xsd/maven-4.0.0.xsd">​
<build>​
<plugins>​
<plugin>​
<groupId>org.owasp</groupId>​
<artifactId>dependency-check-maven</artifactId>​
<version>10.0.2</version> <configuration>​
<failBuildOnCVSS>7.0</failBuildOnCVSS> <formats>​
<format>HTML</format> <format>JSON</format>​
<format>XML</format>​
</formats>​
<outputDirectory>${project.build.directory}/dependency-check-reports</outputDirectory>​
​
<nvdApiKey>${env.NVD_API_KEY}</nvdApiKey> <nvdApiDelay>3000</nvdApiDelay>
<dataDirectory>${project.build.directory}/dependency-check-data</dataDirectory>​
<autoUpdate>true</autoUpdate> <suppressionFiles>​
</suppressionFiles> <assemblyAnalyzerEnabled>false</assemblyAnalyzerEnabled>​
<nuspecAnalyzerEnabled>false</nuspecAnalyzerEnabled>​<centralAnalyzerEnabled>true</centralAnalyzerEnabled>
<cmakeAnalyzerEnabled>false</cmakeAnalyzerEnabled>​
<composerAnalyzerEnabled>false</composerAnalyzerEnabled>​
<autoconfAnalyzerEnabled>false</autoconfAnalyzerEnabled>​
<nodeAnalyzerEnabled>false</nodeAnalyzerEnabled>
<retireJsAnalyzerEnabled>false</retireJsAnalyzerEnabled>
<swiftPackageManagerAnalyzerEnabled>false</swiftPackageManagerAnalyzerEnabled>​
<cocoapodsAnalyzerEnabled>false</cocoapodsAnalyzerEnabled>​
<rubyGemspecAnalyzerEnabled>false</rubyGemspecAnalyzerEnabled>​
<pythonDistributionAnalyzerEnabled>false</pythonDistributionAnalyzerEnabled>​
<jarAnalyzerEnabled>true</jarAnalyzerEnabled> <skipTestScope>true</skipTestScope>​
<skipRuntimeScope>false</skipRuntimeScope>​
<skipProvidedScope>false</skipProvidedScope>​
<skipSystemScope>true</skipSystemScope>​
​
</configuration>​
<executions>​
<execution>​
<goals>​
<goal>check</goal> </goals>​
</execution>​
</executions>​
</plugin>​
</plugins>​
</build>​
</project>​
Explicação da Configuração:
●​ <version>: Especifica a versão do plugin. É importante usar a versão mais recente
e estável.
●​ <failBuildOnCVSS>: Define um limiar de pontuação CVSS (Common Vulnerability
Scoring System). Se qualquer dependência tiver uma vulnerabilidade com uma
pontuação CVSS igual ou superior a este valor, o build Maven falhará.29 Um valor
de 7.0 ou superior geralmente indica vulnerabilidades de alta severidade.
●​ <formats>: Define os formatos dos relatórios gerados (HTML, JSON, XML).30 O
HTML é útil para análise manual, enquanto JSON/XML podem ser usados para
integração com outras ferramentas.
●​ <outputDirectory>: Especifica o diretório onde os relatórios serão salvos.
●​ <nvdApiKey>: Permite configurar uma chave de API da NVD (NationalVulnerability Database). O uso de uma chave de API é altamente recomendado,
pois o acesso não autenticado à API da NVD é severamente limitado em taxa, o
que pode tornar os scans muito lentos ou falhar.30 A chave pode ser passada
como uma variável de ambiente (env.NVD_API_KEY).
●​ <nvdApiDelay>: Um pequeno atraso entre as chamadas à API NVD pode ajudar a
evitar o rate limiting.31
●​ <dataDirectory>: Especifica um diretório para armazenar em cache os dados da
NVD baixados. Isso pode acelerar significativamente os scans subsequentes,
especialmente em ambientes de CI/CD.
●​ <autoUpdate>: Garante que os dados da NVD sejam atualizados antes do scan.
●​ <suppressionFiles>: Permite especificar um ou mais arquivos XML para suprimir
falsos positivos ou vulnerabilidades que foram avaliadas e aceitas como um
risco.30 Este é um aspecto crucial do gerenciamento de vulnerabilidades de
dependências.
●​ <analyzersEnabled> / <retireJsAnalyzerEnabled> etc.: Permite habilitar ou
desabilitar analisadores específicos. Para um projeto backend Java como a Atous,
analisadores para Node.js, Ruby, Swift, etc., podem ser desabilitados para
acelerar o scan se não forem relevantes.29 O jarAnalyzerEnabled e
centralAnalyzerEnabled são importantes para projetos Maven.
●​ <skipTestScope>: Geralmente definido como true para não escanear
dependências de escopo de teste, pois elas não são empacotadas na aplicação
final.
●​ <executions> e <goal>check</goal>: Configura o plugin para executar o goal
check automaticamente, geralmente durante a fase verify do ciclo de vida do
Maven.29
6.2. Executando a Análise e Interpretando Relatórios
Para executar a análise:
●​ Se configurado na seção <executions>, o plugin rodará automaticamente durante
a fase verify do Maven:​
Bash​
mvn verify​
●​ Para executar manualmente:​
Bash​
mvn org.owasp:dependency-check-maven:check​
# Ou de forma mais curta, se o prefixo do plugin estiver configurado:​
# mvn dependency-check:check​●​ Para apenas atualizar os dados da NVD (útil para pré-cache em CI):​
Bash​
mvn dependency-check:update-only​
30
Interpretando os Relatórios:
Após a execução, os relatórios serão gerados no diretório especificado (e.g.,
target/dependency-check-reports/). O relatório HTML
(dependency-check-report.html) é o mais amigável para análise manual. Ele listará:
●​
●​
●​
●​
Cada dependência do projeto.
Quaisquer vulnerabilidades conhecidas (CVEs) associadas a cada dependência.
A severidade de cada vulnerabilidade (pontuação CVSS).
Links para os detalhes da CVE na NVD e outras fontes.
Ações com base nos relatórios:
1.​ Priorizar Vulnerabilidades: Focar primeiro nas vulnerabilidades com as maiores
pontuações CVSS.
2.​ Atualizar Dependências: A ação mais comum é atualizar a dependência
vulnerável para uma versão mais recente que corrija a falha.
3.​ Analisar o Uso: Se uma atualização não for possível imediatamente, analisar se a
funcionalidade vulnerável da dependência está realmente sendo usada pela
Atous. Se não estiver, o risco pode ser menor (mas a dependência ainda deve ser
atualizada eventualmente).
4.​ Supressão (com cautela):
○​ Se uma vulnerabilidade for um falso positivo (o Dependency-Check
identificou incorretamente a dependência ou a vulnerabilidade não se aplica).
○​ Se uma vulnerabilidade tiver um risco muito baixo no contexto da Atous e a
atualização causar problemas significativos (risco aceito).
○​ Nesses casos, criar uma entrada no arquivo de supressão XML. O relatório
HTML geralmente fornece um snippet XML de supressão para cada
vulnerabilidade encontrada, facilitando esse processo.
○​ Exemplo de owasp-suppressions.xml:​
XML​
<?xml version="1.0" encoding="UTF-8"?>​
<suppressions
xmlns="https://jeremylong.github.io/DependencyCheck/dependency-suppression.1.3.xsd">​
<suppress>​
<notes><! em.​
]]></notes>​<packageUrl
regex="true">^pkg:maven/com\.example/some\-library@.*$</packageUrl>​
<cve>CVE-YYYY-XXXXX</cve>​
</suppress>​
</suppressions>​
6.3. Integrando no Pipeline CI/CD da Atous
A verificação de dependências deve ser uma parte automatizada do pipeline de
Integração Contínua/Entrega Contínua (CI/CD) da Atous.
●​ Execução: O comando mvn verify (que inclui dependency-check:check) deve ser
executado em cada build.
●​ Falha no Build: Configurar failBuildOnCVSS para um limiar apropriado garante
que o build falhe se vulnerabilidades críticas forem introduzidas, prevenindo sua
implantação.
●​ Cache de Dados NVD: Em ambientes CI/CD, configurar o dataDirectory e usar
mecanismos de cache do CI (como o cache do GitLab CI 31 ou o cache do GitHub
Actions) para o diretório de dados da NVD pode economizar tempo significativo,
evitando o download completo dos dados da NVD a cada build.
●​ Armazenamento de Relatórios: Arquivar os relatórios HTML/JSON/XML como
artefatos do build para referência e auditoria.
A utilização sistemática do OWASP Dependency-Check é uma medida de segurança
proativa fundamental para a Rede Atous, ajudando a reduzir a superfície de ataque
proveniente de componentes de terceiros. O gerenciamento de falsos positivos
através de arquivos de supressão é uma prática importante para manter a eficácia e a
relevância da ferramenta a longo prazo.
Seção 7: Scripts de Teste de Penetração para Atous: Passo a
Passo
Esta seção detalha scripts práticos em Java (com Spring), Bash e Python para realizar
testes de penetração nos diversos componentes da Rede Atous. O objetivo é fornecer
exemplos concretos que podem ser adaptados e expandidos para uma cobertura de
segurança completa.
Tabela Resumo dos Scripts de Pentesting e Cobertura
Linguagem do
Nome/Propósit
Componente
Tipo de
Vulnerabilidad
Referência
OWASP (seScripto do ScriptAtous Alvoe Testadaaplicável)
Java (Spring
Test)TaskControllerA
uthTestAPI REST
(TaskController)Autenticação,
Autorização
(Controle de
Acesso
Quebrado)A01:2021-Broke
n Access
Control,
A07:2021-Identif
ication and
Authentication
Failures
Java (Spring
Test)Testes de
Validação de
Entrada para
DTOs/Comando
sAPI REST
(Controladores,
Casos de Uso)Injeção (SQLi,
XSS, Command
Injection se
aplicável),
Validação de
Entrada
IncorretaA03:2021-Injecti
on
Java (Spring
Test)Testes de
Lógica de
Negócios para
Casos de UsoCamada de
Aplicação
(UseCases)Falhas na Lógica
de Negócios,
Condições de
Corrida,
Manipulação de
Estado IncorretaA04:2021-Insec
ure Design
Bashnmap_scan_ato
us.shNós Atous
(Rede)Reconheciment
o de Rede,
Varredura de
Portas,
Identificação de
Serviços
ExpostosA05:2021-Secur
ity
Misconfiguratio
n
BashScripts de
Enumeração de
Serviços (e.g.,
check_postgres.
sh)PostgreSQL,
Redis, Kafka
(Serviços de
Infraestrutura)Identificação de
Versões,
Vulnerabilidades
Conhecidas em
Serviços,
Configurações
Incorretas
Comuns (e.g.,
credenciais
padrão)A05:2021-Secur
ity
Misconfiguratio
n,
A06:2021-Vulner
able and
Outdated
ComponentsPython (pytest)test_api_fuzzing.
py (Task ID
Fuzzing)API REST
(Endpoints
específicos)Injeção, Erros
Inesperados,
Vazamento de
Informação,
Negação de
Serviço (DoS)
por entradas
malformadasA03:2021-Injecti
on
Python
(requests)Scripts de
Exploração
Controlada
(Exemplo
Conceitual)API REST,
Camada de
DadosDemonstração
de impacto de
vulnerabilidades
como SQLi,
Command
Injection
(apenas em
ambiente de
teste isolado)A03:2021-Injecti
on
Python (custom)Scripts de
Interação com
Protocolos
P2P/KafkaRede P2P Atous,
Brokers KafkaRobustez de
Parsers,
Tratamento de
Mensagens
Malformadas/In
esperadas,
Potenciais DoS
em protocolosA04:2021-Insec
ure Design,
A08:2021-Softw
are and Data
Integrity Failures
Bash (ZAP
Docker)zap_api_scan_at
ous.shAPI REST da
AtousOWASP Top 10
para APIs
(Injeção,
Controle de
Acesso
Quebrado,
Falhas
Criptográficas,
etc.),
Configurações
Incorretas de
APIOWASP Top 10
(geral),
especificamente
A01, A02, A03,
A05, A07, A10
para APIs. Ver
também OWASP
API Security Top
10.
7.1. Scripts Java/Spring para Teste de Lógica de Aplicação e Fluxo
Os testes em Java, utilizando o ecossistema Spring (Spring Test, Spring Security Test,MockMvc), são fundamentais para validar a segurança da lógica interna da aplicação
Atous.
7.1.1. Testando Mecanismos de Autenticação e Autorização
A segurança da Rede Atous depende criticamente de mecanismos robustos de
autenticação e autorização para seus endpoints de API.1 Spring Security é a base para
essa proteção, e seus testes podem ser realizados com @WithMockUser e MockMvc
para simular diferentes cenários de acesso.32
Exemplo de Script (Teste de Endpoint com Spring Security e MockMvc para
TaskController):
O código a seguir demonstra como testar o TaskController da Atous, focando em
cenários de autenticação e autorização para o endpoint de submissão de tarefas.
Java
// No módulo 'infrastructure' ou em um módulo de teste dedicado​
// Pacote: com.atous.infrastructure.web.task.controller​
​
import org.junit.jupiter.api.Test;​
import org.springframework.beans.factory.annotation.Autowired;​
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;​
import org.springframework.boot.test.mock.mockito.MockBean;​
import org.springframework.context.annotation.Import;​
import org.springframework.http.MediaType;​
import org.springframework.security.test.context.support.WithMockUser;​
import org.springframework.test.web.servlet.MockMvc;​
​
import static
org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostP
rocessors.csrf;​
import static
org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;​
import static
org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;​
import static org.mockito.ArgumentMatchers.any;​import static org.mockito.BDDMockito.given;​
​
import com.atous.application.task.usecase.SubmitTaskUseCase;​
import com.atous.application.task.dto.SubmitTaskCommand;​
import com.atous.application.task.dto.TaskReceiptDto;​
// Importar a classe de configuração de segurança, se necessário para carregar o contexto
corretamente​
// import com.atous.infrastructure.config.SecurityConfig; ​
import com.atous.infrastructure.web.task.dto.TaskSubmissionApiRequest; // DTO da API​
import com.fasterxml.jackson.databind.ObjectMapper;​
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;​
​
import java.time.Instant;​
import java.util.Collections;​
​
// @Import(SecurityConfig.class) // Importar a configuração de segurança se não for auto-detectada​
@WebMvcTest(TaskController.class) // Foca no TaskController e carrega o contexto Spring MVC mínimo​
public class TaskControllerAuthTest {​
​
@Autowired​
private MockMvc mockMvc;​
​
@MockBean // Mocka o Caso de Uso para isolar o teste do controlador​
private SubmitTaskUseCase submitTaskUseCase;​
​
// ObjectMapper para serializar o corpo da requisição​
private final ObjectMapper objectMapper = new ObjectMapper().registerModule(new
JavaTimeModule());​
​
@Test​
@WithMockUser(username = "testuser", authorities = {"ATOUS_SUBMIT_TASK"}) // Simula um usuário
autenticado com a permissão necessária​
void whenSubmitTaskWithValidAuthAndPermission_thenReturnsCreated() throws Exception {​
// Given​
TaskSubmissionApiRequest apiRequest = new TaskSubmissionApiRequest(​
"nodeSubmitter123",​
"DATA_PROCESSING",​
"payloadHash123",​
// Supondo que ResourceProfile e TaskSecurityRequirements são Records aninhados ou
mapeados​new TaskSubmissionApiRequest.ResourceProfileRequest(2, "X86_64", 1024, false,
null, 0, 500, 0, 10, false, Collections.emptyMap()),​
Instant.now().plusSeconds(3600).toString(),​
new TaskSubmissionApiRequest.TaskSecurityRequirementsRequest("LEVEL_1",
"CONFIDENTIAL", false),​
5​
);​
TaskReceiptDto receipt = new TaskReceiptDto("taskGeneratedId", "SUBMITTED",
Instant.now());​
// Configura o mock do caso de uso para retornar o recibo esperado​
given(submitTaskUseCase.execute(any(SubmitTaskCommand.class))).willReturn(recei
pt);​
​
// When & Then​
mockMvc.perform(post("/api/v1/atous/tasks")​
.with(csrf()) // Adicionar CSRF token se CSRF protection estiver habilitado (padrão no
Spring Security)​
.contentType(MediaType.APPLICATION_JSON)​
.content(objectMapper.writeValueAsString(apiRequest)))​
.andExpect(status().isCreated()); // HTTP 201​
}​
​
@Test​
void whenSubmitTaskUnauthenticated_thenReturnsUnauthorized() throws Exception {​
// Given​
TaskSubmissionApiRequest apiRequest = new TaskSubmissionApiRequest(​
"nodeSubmitter123", "DATA_PROCESSING", "payloadHash123",​
new TaskSubmissionApiRequest.ResourceProfileRequest(2, "X86_64", 1024, false,
null, 0, 500, 0, 10, false, Collections.emptyMap()),​
Instant.now().plusSeconds(3600).toString(),​
new TaskSubmissionApiRequest.TaskSecurityRequirementsRequest("LEVEL_1",
"CONFIDENTIAL", false),​
5​
);​
​
// When & Then​
mockMvc.perform(post("/api/v1/atous/tasks")​
.with(csrf())​.contentType(MediaType.APPLICATION_JSON)​
.content(objectMapper.writeValueAsString(apiRequest)))​
.andExpect(status().isUnauthorized()); // HTTP 401​
}​
​
@Test​
@WithMockUser(username = "anotheruser", authorities = {"SOME_OTHER_PERMISSION"}) // Usuário
autenticado, mas sem a permissão correta​
void whenSubmitTaskWithInsufficientAuth_thenReturnsForbidden() throws Exception {​
// Given​
TaskSubmissionApiRequest apiRequest = new TaskSubmissionApiRequest(​
"nodeSubmitter123", "DATA_PROCESSING", "payloadHash123",​
new TaskSubmissionApiRequest.ResourceProfileRequest(2, "X86_64", 1024, false,
null, 0, 500, 0, 10, false, Collections.emptyMap()),​
Instant.now().plusSeconds(3600).toString(),​
new TaskSubmissionApiRequest.TaskSecurityRequirementsRequest("LEVEL_1",
"CONFIDENTIAL", false),​
5​
);​
// When & Then​
mockMvc.perform(post("/api/v1/atous/tasks")​
.with(csrf())​
.contentType(MediaType.APPLICATION_JSON)​
.content(objectMapper.writeValueAsString(apiRequest)))​
.andExpect(status().isForbidden()); // HTTP 403​
}​
​
// DTOs internos para o teste, refletindo a estrutura esperada pela API​
// Estes devem corresponder aos DTOs reais definidos em com.atous.infrastructure.web.task.dto​
// Para o propósito deste exemplo, eles são definidos aqui de forma simplificada.​
private record TaskSubmissionApiRequest(​
String submitterNodeld,​
String taskType,​
String payloadHash,​
ResourceProfileRequest resourceRequirements,​
String deadlineIso8601,​
TaskSecurityRequirementsRequest securityRequirements,​
int priority​
) {​
private record ResourceProfileRequest(​int cpuCores, String cpuArch, int ramRequiredMB, boolean gpuRequired,​
String gpuTypePreference, int gpuMemoryMB, int storageRequiredMB,​
int storageIOPS, int networkBandwidthMbps, boolean offGridPreference,​
java.util.Map<String, String> customConstraints​
) {}​
private record TaskSecurityRequirementsRequest(​
String pqcLevel, String dataSensitivity, boolean isolationNeeded​
) {}​
}​
}​
Explicação Passo a Passo do Script Java:
1.​ @WebMvcTest(TaskController.class): Esta anotação do Spring Boot Test é
usada para testar controladores MVC. Ela auto-configura a infraestrutura
MockMvc e limita o scan de componentes apenas ao TaskController especificado,
não carregando todo o contexto da aplicação. Isso torna os testes mais rápidos e
focados.
2.​ @Autowired private MockMvc mockMvc: Injeta uma instância de MockMvc,
que é a principal ferramenta para testar controladores Spring MVC sem a
necessidade de um servidor HTTP real.
3.​ @MockBean private SubmitTaskUseCase submitTaskUseCase: Cria um mock
do SubmitTaskUseCase. Como o foco do teste é o controlador e suas interações
de segurança, o comportamento do caso de uso subjacente é simulado
(mockado) para isolar o teste.
4.​ objectMapper: Uma instância de ObjectMapper do Jackson é usada para
serializar o objeto de requisição (TaskSubmissionApiRequest) para JSON. O
JavaTimeModule é registrado para lidar corretamente com tipos java.time.Instant.
5.​ @Test @WithMockUser(...):
○​ @Test: Anotação padrão do JUnit 5 para marcar um método de teste.
○​ @WithMockUser(username = "testuser", authorities =
{"ATOUS_SUBMIT_TASK"}): Esta anotação do Spring Security Test configura o
contexto de segurança para este método de teste como se um usuário
chamado "testuser" estivesse autenticado e possuísse a autoridade (ou
permissão/role) "ATOUS_SUBMIT_TASK".
6.​ given(submitTaskUseCase.execute(any(SubmitTaskCommand.class))).willR
eturn(receipt): Usando Mockito (given...willReturn), o comportamento do
submitTaskUseCase mockado é definido. Quando seu método execute for
chamado com qualquer instância de SubmitTaskCommand, ele retornará o
receipt pré-definido.7.​ mockMvc.perform(...): Executa uma requisição HTTP simulada:
○​ post("/api/v1/atous/tasks"): Define que é uma requisição POST para o
endpoint especificado.
○​ .with(csrf()): Adiciona um token CSRF (Cross-Site Request Forgery) válido à
requisição. Se a proteção CSRF estiver habilitada no Spring Security (o que é
padrão), isso é necessário para requisições POST, PUT, DELETE.
○​ .contentType(MediaType.APPLICATION_JSON): Define o Content-Type da
requisição como JSON.
○​ .content(objectMapper.writeValueAsString(apiRequest)): Define o corpo da
requisição, serializando o apiRequest para uma string JSON.
8.​ .andExpect(status().isCreated()): Define a asserção esperada. Neste caso,
espera-se que a resposta HTTP tenha o status 201 Created.
9.​ Cenário Não Autenticado: O teste
whenSubmitTaskUnauthenticated_thenReturnsUnauthorized não usa
@WithMockUser, então a requisição é feita como um usuário anônimo. Espera-se
um status 401 Unauthorized.
10.​Cenário com Autorização Insuficiente: O teste
whenSubmitTaskWithInsufficientAuth_thenReturnsForbidden usa
@WithMockUser com uma autoridade diferente ("SOME_OTHER_PERMISSION").
Como essa autoridade provavelmente não concede permissão para submeter
tarefas, espera-se um status 403 Forbidden.
11.​ DTOs Internos para Teste: Os records TaskSubmissionApiRequest,
ResourceProfileRequest e TaskSecurityRequirementsRequest são definidos
dentro da classe de teste para representar a estrutura do payload da API. Em um
projeto real, eles seriam importados do pacote
com.atous.infrastructure.web.task.dto.1
Estes testes validam que os mecanismos de autenticação e autorização configurados
no Spring Security para o TaskController estão funcionando como esperado,
permitindo acesso a usuários com as permissões corretas e bloqueando usuários não
autenticados ou sem as permissões necessárias.
7.1.2. Teste de Validação de Entrada e Injeção
É crucial testar como a aplicação lida com entradas inválidas ou maliciosas. As
validações de DTOs (Data Transfer Objects) e entidades de domínio são a primeira
linha de defesa.1
Exemplo de Script (Teste de Validação de SubmitTaskCommand):Java
// No módulo 'application' ou em um módulo de teste dedicado​
// Pacote: com.atous.application.task.dto​
​
import jakarta.validation.ConstraintViolation;​
import jakarta.validation.Validation;​
import jakarta.validation.Validator;​
import jakarta.validation.ValidatorFactory;​
import org.junit.jupiter.api.BeforeAll;​
import org.junit.jupiter.api.Test;​
import static org.assertj.core.api.Assertions.assertThat;​
​
import java.time.Instant;​
import java.util.Collections;​
import java.util.Set;​
​
// Supondo que SubmitTaskCommand e seus Records aninhados usam anotações Bean Validation
(@NotNull, @Size, etc.)​
// Exemplo de SubmitTaskCommand (simplificado, deve corresponder à definição real)​
// package com.atous.application.task.dto;​
// import jakarta.validation.Valid;​
// import jakarta.validation.constraints.NotBlank;​
// import jakarta.validation.constraints.NotNull;​
// import jakarta.validation.constraints.Future;​
// //... outros imports...​
// public record SubmitTaskCommand(​
// @NotBlank String submitterNodeld,​
// @NotBlank String taskType,​
// @NotBlank String payloadHash,​
// @NotNull @Valid ResourceProfileCommand resourceRequirements,​
// @NotNull @Future Instant deadline,​
// @NotNull @Valid TaskSecurityRequirementsCommand securityRequirements,​
// int priority​
// ) {​
// public record ResourceProfileCommand(/*... campos com anotações... */) {}​
// public record TaskSecurityRequirementsCommand(/*... campos com anotações... */) {}​
// }​
​
​public class SubmitTaskCommandValidationTest {​
​
private static Validator validator;​
​
@BeforeAll​
static void setUp() {​
ValidatorFactory factory = Validation.buildDefaultValidatorFactory();​
validator = factory.getValidator();​
}​
​
// Definições simplificadas dos DTOs aninhados para o teste​
private record ResourceProfileCommandTest(int cpuCores) {}​
private record TaskSecurityRequirementsCommandTest(String pqcLevel) {}​
​
​
@Test​
void whenSubmitterNodeIdIsNull_thenValidationFails() {​
// Given​
// Recriando uma estrutura similar a SubmitTaskCommand para teste, assumindo que os campos
são validados com @NotBlank/@NotNull​
// Em um cenário real, você usaria os DTOs reais.​
var command = new com.atous.application.task.dto.SubmitTaskCommand(​
null, // submitterNodeld é nulo​
"TYPE_A",​
"hash123",​
new
com.atous.application.task.dto.SubmitTaskCommand.ResourceProfileCommand(2,
"X86_64", 1024, false, null, 0, 0, 0, 0, false, Collections.emptyMap()),​
Instant.now().plusSeconds(3600),​
new
com.atous.application.task.dto.SubmitTaskCommand.TaskSecurityRequirementsCom
mand("LEVEL_1", "CONFIDENTIAL", false),​
5​
);​
​
// When​
Set<ConstraintViolation<com.atous.application.task.dto.SubmitTaskCommand>>
violations = validator.validate(command);​
​// Then​
assertThat(violations).isNotEmpty();​
assertThat(violations).anyMatch(v ->
v.getPropertyPath().toString().equals("submitterNodeld") &&​
v.getMessage().contains("não deve estar em branco")); // Ajustar
mensagem conforme a anotação​
}​
​
@Test​
void whenDeadlineIsInPast_thenValidationFails() {​
// Given​
var command = new com.atous.application.task.dto.SubmitTaskCommand(​
"node123",​
"TYPE_A",​
"hash123",​
new
com.atous.application.task.dto.SubmitTaskCommand.ResourceProfileCommand(2,
"X86_64", 1024, false, null, 0, 0, 0, 0, false, Collections.emptyMap()),​
Instant.now().minusSeconds(3600), // Deadline no passado​
new
com.atous.application.task.dto.SubmitTaskCommand.TaskSecurityRequirementsCom
mand("LEVEL_1", "CONFIDENTIAL", false),​
5​
);​
​
// When​
Set<ConstraintViolation<com.atous.application.task.dto.SubmitTaskCommand>>
violations = validator.validate(command);​
​
// Then​
assertThat(violations).isNotEmpty();​
assertThat(violations).anyMatch(v ->
v.getPropertyPath().toString().equals("deadline") &&​
v.getMessage().contains("deve ser uma data futura")); // Ajustar
mensagem conforme @Future​
}​
​
// Adicionar mais testes para outros campos e tipos de validação (e.g., @Size, @Pattern, validações
customizadas)​// e para os campos dentro dos Records aninhados (ResourceProfileCommand,
TaskSecurityRequirementsCommand)​
// se eles tiverem suas próprias anotações de validação e o SubmitTaskCommand usar @Valid neles.​
}​
Explicação Passo a Passo do Script Java:
1.​ Validator Setup: Um Validator do Bean Validation (Jakarta Validation) é obtido
para realizar as validações programaticamente.
2.​ Cenários de Teste:
○​ whenSubmitterNodeIdIsNull_thenValidationFails: Testa se a validação falha
(produzindo uma ConstraintViolation) quando o campo submitterNodeld é
nulo (assumindo que ele está anotado com @NotBlank ou @NotNull no
SubmitTaskCommand real).
○​ whenDeadlineIsInPast_thenValidationFails: Testa se a validação falha quando
o deadline é uma data no passado (assumindo @Future).
3.​ Asserções: assertThat(violations) do AssertJ é usado para verificar se o conjunto
de violações não está vazio e se contém a violação esperada para o campo e a
mensagem de erro corretos.
4.​ DTOs Reais: É crucial que os testes de validação usem as definições reais dos
DTOs da camada de aplicação (e.g.,
com.atous.application.task.dto.SubmitTaskCommand e seus componentes
aninhados), que devem conter as anotações de Bean Validation (@NotNull,
@NotBlank, @Size, @Min, @Pattern, @Valid para objetos aninhados, etc.).
Para testar contra injeções mais complexas (SQLi, XSS, Command Injection), os testes
unitários de validação de DTOs são um primeiro passo. Testes de integração que
enviam payloads maliciosos através dos controladores (como no exemplo de fuzzing
com Python na Seção 7.3.1) complementam essa abordagem.
7.1.3. Teste de Falhas na Lógica de Negócios em Casos de Uso
Os Casos de Uso (e.g., SubmitTaskUseCase, ProcessSecurityEventUseCase 1) contêm
a lógica de orquestração principal. É vital testar cenários de borda e condições que
podem levar a falhas.
Exemplo de Script (Teste de Lógica em SubmitTaskUseCase):
Java// No módulo 'application' ou em um módulo de teste dedicado​
// Pacote: com.atous.application.task.usecase​
​
import org.junit.jupiter.api.Test;​
import org.junit.jupiter.api.extension.ExtendWith;​
import org.mockito.InjectMocks;​
import org.mockito.Mock;​
import org.mockito.junit.jupiter.MockitoExtension;​
​
import static org.assertj.core.api.Assertions.assertThatThrownBy;​
import static org.mockito.Mockito.*;​
​
import com.atous.core.domain.node.NodeInfo;​
import com.atous.core.domain.node.NodeStatus;​
import com.atous.core.domain.node.port.NodeRepositoryPort;​
import com.atous.core.domain.pqc.PQCKey; // Supondo que PQCKey é necessário para
NodeInfo​
import com.atous.core.domain.pqc.KeyType; // Supondo que KeyType é necessário para
PQCKey​
import com.atous.core.domain.task.TaskDefinition;​
import com.atous.core.domain.task.port.TaskRepositoryPort;​
import com.atous.application.task.dto.SubmitTaskCommand;​
import com.atous.application.task.dto.TaskReceiptDto;​
import com.atous.application.task.event.TaskEventProducerPort; // Supondo esta interface​
import com.atous.application.exception.NodeNotFoundException; // Exceção customizada​
import com.atous.application.exception.TaskSubmissionException; // Exceção customizada​
​
import java.time.Instant;​
import java.util.Collections;​
import java.util.List;​
import java.util.Optional;​
​
@ExtendWith(MockitoExtension.class)​
public class SubmitTaskUseCaseTest {​
​
@Mock​
private TaskRepositoryPort taskRepositoryPort;​
​
@Mock​private NodeRepositoryPort nodeRepositoryPort;​
​
@Mock​
private TaskEventProducerPort taskEventProducerPort; // Mock para o produtor de eventos
Kafka​
​
@InjectMocks // Cria uma instância de SubmitTaskUseCase e injeta os mocks acima​
private SubmitTaskUseCase submitTaskUseCase;​
​
// Definições simplificadas de DTOs aninhados para o comando​
private SubmitTaskCommand.ResourceProfileCommand validResourceProfile =​
new SubmitTaskCommand.ResourceProfileCommand(2, "X86_64", 1024, false, null, 0,
0, 0, 0, false, Collections.emptyMap());​
private SubmitTaskCommand.TaskSecurityRequirementsCommand
validSecurityRequirements =​
new SubmitTaskCommand.TaskSecurityRequirementsCommand("LEVEL_1",
"CONFIDENTIAL", false);​
​
@Test​
void whenSubmitterNodeNotFound_thenThrowsNodeNotFoundException() {​
// Given​
SubmitTaskCommand command = new SubmitTaskCommand(​
"unknownNodeId", "TYPE_A", "hash123",​
validResourceProfile, Instant.now().plusSeconds(3600),
validSecurityRequirements, 5​
);​
when(nodeRepositoryPort.findById("unknownNodeId")).thenReturn(Optional.empty());​
​
// When & Then​
assertThatThrownBy(() -> submitTaskUseCase.execute(command))​
.isInstanceOf(NodeNotFoundException.class)​
.hasMessageContaining("unknownNodeId");​
​
verify(taskRepositoryPort, never()).save(any(TaskDefinition.class));​
verify(taskEventProducerPort, never()).publishTaskSubmitted(any());​
}​
​
@Test​void whenSubmitterNodeNotActive_thenThrowsTaskSubmissionException() {​
// Given​
String submitterId = "inactiveNodeId";​
PQCKey dummyPqcKey = new PQCKey("algo", new byte{1}, KeyType.PUBLIC); // Chave
PQC de exemplo​
NodeInfo inactiveNode = new NodeInfo(submitterId, "address", dummyPqcKey,
List.of("COMPUTE"), NodeStatus.INACTIVE, Instant.now(), 0.8);​
SubmitTaskCommand command = new SubmitTaskCommand(​
submitterId, "TYPE_A", "hash123",​
validResourceProfile, Instant.now().plusSeconds(3600),
validSecurityRequirements, 5​
);​
when(nodeRepositoryPort.findById(submitterId)).thenReturn(Optional.of(inactiveNode
));​
​
// When & Then​
assertThatThrownBy(() -> submitTaskUseCase.execute(command))​
.isInstanceOf(TaskSubmissionException.class)​
.hasMessageContaining("Submitter node is not eligible");​
​
verify(taskRepositoryPort, never()).save(any(TaskDefinition.class));​
}​
​
@Test​
void whenSubmitterNodeReputationTooLow_thenThrowsTaskSubmissionException() {​
// Given​
String submitterId = "lowRepNodeId";​
PQCKey dummyPqcKey = new PQCKey("algo", new byte{1}, KeyType.PUBLIC);​
NodeInfo lowRepNode = new NodeInfo(submitterId, "address", dummyPqcKey,
List.of("COMPUTE"), NodeStatus.ACTIVE, Instant.now(), 0.2); // Reputação baixa​
SubmitTaskCommand command = new SubmitTaskCommand(​
submitterId, "TYPE_A", "hash123",​
validResourceProfile, Instant.now().plusSeconds(3600),
validSecurityRequirements, 5​
);​
// Supondo que o limite de reputação no SubmitTaskUseCase é 0.5​
when(nodeRepositoryPort.findById(submitterId)).thenReturn(Optional.of(lowRepNode));​
​
// When & Then​
assertThatThrownBy(() -> submitTaskUseCase.execute(command))​
.isInstanceOf(TaskSubmissionException.class)​
.hasMessageContaining("Submitter node is not eligible");​
}​
​
​
@Test​
void whenDeadlineInPast_thenThrowsIllegalArgumentException() {​
// Given​
String submitterId = "validNode";​
PQCKey dummyPqcKey = new PQCKey("algo", new byte{1}, KeyType.PUBLIC);​
NodeInfo validNode = new NodeInfo(submitterId, "address", dummyPqcKey,
List.of("COMPUTE"), NodeStatus.ACTIVE, Instant.now(), 0.9);​
SubmitTaskCommand command = new SubmitTaskCommand(​
submitterId, "TYPE_A", "hash123",​
validResourceProfile, Instant.now().minusSeconds(3600), // Deadline no passado​
validSecurityRequirements, 5​
);​
when(nodeRepositoryPort.findById(submitterId)).thenReturn(Optional.of(validNode));​
​
// When & Then​
assertThatThrownBy(() -> submitTaskUseCase.execute(command))​
.isInstanceOf(IllegalArgumentException.class)​
.hasMessageContaining("Task deadline must be in the future");​
}​
​
@Test​
void whenCommandIsValid_thenTaskIsSavedAndEventPublished() {​
// Given​
String submitterId = "validNode";​
PQCKey dummyPqcKey = new PQCKey("algo", new byte{1}, KeyType.PUBLIC);​
NodeInfo validNode = new NodeInfo(submitterId, "address", dummyPqcKey,
List.of("COMPUTE"), NodeStatus.ACTIVE, Instant.now(), 0.9);​
SubmitTaskCommand command = new SubmitTaskCommand(​
submitterId, "TYPE_A", "hash123",​validResourceProfile, Instant.now().plusSeconds(3600),
validSecurityRequirements, 5​
);​
when(nodeRepositoryPort.findById(submitterId)).thenReturn(Optional.of(validNode));​
// Não precisamos mockar taskRepositoryPort.save() ou
taskEventProducerPort.publishTaskSubmitted()​
// a menos que queiramos verificar os argumentos passados a eles com ArgumentCaptor.​
// Para este teste, apenas verificar que são chamados é suficiente.​
​
// When​
TaskReceiptDto receipt = submitTaskUseCase.execute(command);​
​
// Then​
uso​
assertThat(receipt).isNotNull();​
assertThat(receipt.status()).isEqualTo("SUBMITTED"); // Conforme a lógica do caso de
assertThat(receipt.taskId()).isNotNull();​
​
verify(taskRepositoryPort, times(1)).save(any(TaskDefinition.class));​
verify(taskEventProducerPort, times(1)).publishTaskSubmitted(any());​
}​
}​
Explicação Passo a Passo do Script Java:
1.​ @ExtendWith(MockitoExtension.class): Habilita a integração do Mockito com
JUnit 5 para criação e injeção de mocks.
2.​ @Mock: Cria mocks para as dependências do SubmitTaskUseCase
(TaskRepositoryPort, NodeRepositoryPort, TaskEventProducerPort).
3.​ @InjectMocks: Cria uma instância real de SubmitTaskUseCase e injeta os mocks
criados acima em seus campos correspondentes.
4.​ Cenários de Teste:
○​ whenSubmitterNodeNotFound_thenThrowsNodeNotFoundException: Simula o
caso onde o NodeRepositoryPort não encontra o nó submissor. Espera-se
que uma NodeNotFoundException seja lançada e que os métodos de salvar
tarefa ou publicar evento não sejam chamados.
○​ whenSubmitterNodeNotActive_thenThrowsTaskSubmissionException: Simula
um nó submissor que existe mas está inativo. Espera-se uma
TaskSubmissionException.○​ whenSubmitterNodeReputationTooLow_thenThrowsTaskSubmissionException:
Simula um nó ativo mas com reputação abaixo do limiar (a lógica de limite de
reputação está no SubmitTaskUseCase 1).
○​ whenDeadlineInPast_thenThrowsIllegalArgumentException: Simula um
comando com prazo no passado.
○​ whenCommandIsValid_thenTaskIsSavedAndEventPublished: Testa o fluxo feliz.
Simula um nó válido e um comando válido. Verifica se o método save do
TaskRepositoryPort e o método publishTaskSubmitted do
TaskEventProducerPort são chamados uma vez, e se um TaskReceiptDto
válido é retornado.
5.​ when(...).thenReturn(...): Configura o comportamento dos mocks. Por exemplo,
when(nodeRepositoryPort.findById("unknownNodeId")).thenReturn(Optional.emp
ty()) faz com que a chamada findById com "unknownNodeId" retorne um Optional
vazio.
6.​ assertThatThrownBy(...): Usado para testar cenários onde se espera que uma
exceção seja lançada. Verifica o tipo da exceção e, opcionalmente, parte da
mensagem.
7.​ verify(...): Usado para verificar se os métodos dos mocks foram chamados (ou
não chamados, com never()) com os parâmetros esperados ou um número
específico de vezes (times(1)).
Estes testes unitários para Casos de Uso são vitais para garantir que a lógica de
negócios principal da Atous seja correta e resiliente a condições de erro.
7.2. Scripts Bash para Teste de Rede e Infraestrutura
Scripts Bash são úteis para testes rápidos de conectividade de rede, varredura de
portas e verificações básicas de configuração da infraestrutura que suporta a Atous.
7.2.1. Reconhecimento de Rede e Varredura de Portas
Identificar quais serviços e portas estão expostos por um nó Atous é um primeiro
passo fundamental em qualquer avaliação de segurança.
Exemplo de Script (Nmap Básico e Netcat):
Bash
#!/bin/bash​​
# Script para reconhecimento básico de um nó Atous​
# Uso:./atous_node_recon.sh <IP_DO_NO_ATOUS>​
​
TARGET_HOST=$1​
OUTPUT_DIR="pentest_reports/atous_node_${TARGET_HOST}"​
NMAP_OUTPUT_FILE="${OUTPUT_DIR}/nmap_scan.txt"​
NC_API_PORT_OUTPUT_FILE="${OUTPUT_DIR}/nc_api_port_check.txt"​
NC_P2P_PORT_OUTPUT_FILE="${OUTPUT_DIR}/nc_p2p_port_check.txt"​
​
# Portas esperadas para a Atous (ajustar conforme a configuração real)​
ATOUS_API_PORT=${ATOUS_API_PORT:-8080} # Porta da API REST​
ATOUS_P2P_PORT=${ATOUS_P2P_PORT:-30303} # Porta de comunicação P2P (exemplo)​
​
if; then​
echo "Erro: IP do nó Atous alvo não fornecido."​
echo "Uso: $0 <IP_DO_NO_ATOUS>"​
exit 1​
fi​
​
echo "Iniciando reconhecimento no nó Atous: $TARGET_HOST"​
mkdir -p "$OUTPUT_DIR"​
​
# --- Varredura de Portas com Nmap ---​
echo "[*] Executando varredura de portas completa com Nmap (pode levar tempo)..."​
# -sV: Tenta determinar a versão dos serviços rodando nas portas abertas​
# -p-: Escaneia todas as 65535 portas TCP​
# -oN: Salva a saída em formato normal​
# -T4: Define o template de timing para "agressivo" (mais rápido, mas pode ser detectado)​
# Considerar -Pn se o host não responder a pings (ICMP bloqueado)​
nmap -sV -p- -T4 "$TARGET_HOST" -oN "$NMAP_OUTPUT_FILE"​
echo "[+] Varredura Nmap concluída. Relatório salvo em: $NMAP_OUTPUT_FILE"​
echo "-----------------------------------------------------"​
cat "$NMAP_OUTPUT_FILE"​
echo "-----------------------------------------------------"​
​
# --- Verificação de Portas Específicas com Netcat ---​
echo "[*] Verificando conectividade com a porta da API Atous ($ATOUS_API_PORT) usando Netcat..."​
# -z: Modo de varredura (não envia dados)​
# -v: Verboso​
# -w <timeout>: Define um timeout para a conexão (e.g., 3 segundos)​if nc -zvw3 "$TARGET_HOST" "$ATOUS_API_PORT" > "$NC_API_PORT_OUTPUT_FILE" 2>&1; then​
echo "[+] Porta da API Atous ($ATOUS_API_PORT) está aberta."​
else​
echo "[-] Porta da API Atous ($ATOUS_API_PORT) está fechada ou inacessível."​
fi​
cat "$NC_API_PORT_OUTPUT_FILE"​
echo "-----------------------------------------------------"​
​
echo "[*] Verificando conectividade com a porta P2P Atous ($ATOUS_P2P_PORT) usando Netcat..."​
if nc -zvw3 "$TARGET_HOST" "$ATOUS_P2P_PORT" > "$NC_P2P_PORT_OUTPUT_FILE" 2>&1; then​
echo "[+] Porta P2P Atous ($ATOUS_P2P_PORT) está aberta."​
else​
echo "[-] Porta P2P Atous ($ATOUS_P2P_PORT) está fechada ou inacessível."​
fi​
cat "$NC_P2P_PORT_OUTPUT_FILE"​
echo "-----------------------------------------------------"​
​
echo "[+] Reconhecimento básico concluído para $TARGET_HOST."​
echo "Relatórios detalhados em: $OUTPUT_DIR"​
Explicação Passo a Passo do Script Bash:
1.​ TARGET_HOST: Recebe o endereço IP do nó Atous como argumento de linha de
comando.
2.​ OUTPUT_DIR: Define um diretório para salvar os relatórios gerados.
3.​ Portas Esperadas: ATOUS_API_PORT e ATOUS_P2P_PORT são definidas (com
valores padrão que podem ser sobrescritos por variáveis de ambiente) para as
portas esperadas da API e da comunicação P2P da Atous.
4.​ Validação de Entrada: Verifica se o IP do alvo foi fornecido.
5.​ Varredura Nmap:
○​ nmap -sV -p- -T4 "$TARGET_HOST" -oN "$NMAP_OUTPUT_FILE":
■​ -sV: Tenta identificar as versões dos serviços rodando nas portas abertas.
■​ -p-: Escaneia todas as 65535 portas TCP. Para UDP, seria -sU -p-.
■​ -T4: Usa um template de timing agressivo para acelerar o scan. Em um
pentest real, pode-se usar -T3 (normal) ou menos para ser mais furtivo.
■​ -oN "$NMAP_OUTPUT_FILE": Salva a saída no formato normal de Nmap
para o arquivo especificado.
6.​ Verificação Netcat:
○​ nc -zvw3 "$TARGET_HOST" "$PORTA":
■​ -z: Modo de varredura de portas (zero-I/O mode), apenas verifica se aporta está aberta sem enviar dados.
■​ -v: Modo verboso, mostra mais informações.
■​ -w3: Define um timeout de 3 segundos para a tentativa de conexão.
○​ O script verifica as portas configuradas para a API e P2P.
7.​ Saída: O script imprime um resumo no console e salva os relatórios detalhados
do Nmap e Netcat no diretório OUTPUT_DIR.
Este script fornece uma visão inicial da superfície de ataque de rede de um nó Atous.
7.2.2. Enumeração de Serviços e Identificação de Vulnerabilidades
Após identificar portas abertas, o próximo passo é enumerar os serviços e procurar
por vulnerabilidades conhecidas.
Exemplo de Script (Verificação de Banner PostgreSQL - Conceitual):
Bash
#!/bin/bash​
​
# Script para tentar obter o banner de um serviço PostgreSQL​
# Uso:./check_postgres_banner.sh <IP_DO_HOST_PG> <PORTA_PG>​
​
PG_HOST=$1​
PG_PORT=${2:-5432} # Porta padrão do PostgreSQL​
​
if; then​
echo "Erro: IP do host PostgreSQL não fornecido."​
echo "Uso: $0 <IP_DO_HOST_PG>"​
exit 1​
fi​
​
echo "[*] Tentando obter banner do PostgreSQL em $PG_HOST:$PG_PORT..."​
​
# Tenta conectar e enviar uma mensagem de startup mínima para provocar uma resposta com versão​
# Esta é uma técnica simples; ferramentas mais sofisticadas podem ser necessárias.​
# O comando 'psql' seria mais eficaz se as credenciais fossem conhecidas ou para testar conexões.​
# Aqui, usamos netcat para uma tentativa de grabbing de banner.​
​
# Envia uma mensagem de startup simples (pode não funcionar em todas as configs PG)​# O formato da mensagem de startup do PostgreSQL é complexo.​
# Uma abordagem mais simples é verificar se a porta responde e usar nmap -sV.​
# Para uma verificação de banner mais direta com netcat, pode-se tentar:​
# echo -e '\x00\x00\x00\x08\x04\xd2\x16\x2f' | nc -w1 $PG_HOST $PG_PORT​
# Mas isso é muito específico e pode não ser universal.​
​
# Uma abordagem mais genérica com timeout:​
RESPONSE=$(nc -w 5 "$PG_HOST" "$PG_PORT" < /dev/null 2>&1)​
​
if [ $? -eq 0 ]; then​
echo "[+] Conexão à porta $PG_PORT bem-sucedida."​
echo " Resposta (pode não conter versão diretamente sem interação de protocolo):"​
echo "$RESPONSE"​
echo " Recomenda-se usar 'nmap -sV $PG_HOST -p $PG_PORT' para identificação de versão mais
precisa."​
else​
echo "[-] Não foi possível conectar à porta $PG_PORT em $PG_HOST ou não houve resposta."​
fi​
​
# Exemplo de como usar psql para verificar a versão se houver acesso e credenciais​
# (requer que o cliente psql esteja instalado e acesso de rede permitido)​
# echo "[*] Tentando obter versão via psql (requer credenciais/acesso)..."​
# PGPASSWORD="dummy" psql -h "$PG_HOST" -p "$PG_PORT" -U "dummyuser" -d "template1" -c
"SELECT version();" -t -A --quiet​
# (O comando acima provavelmente falhará sem credenciais válidas, mas ilustra a ideia)​
Explicação Passo a Passo do Script Bash:
1.​ Parâmetros: Recebe o IP do host PostgreSQL e, opcionalmente, a porta.
2.​ Tentativa de Conexão com Netcat: nc -w 5 "$PG_HOST" "$PG_PORT" <
/dev/null tenta estabelecer uma conexão TCP com a porta especificada com um
timeout de 5 segundos. O < /dev/null é usado para que o nc feche a conexão após
estabelecê-la, em vez de esperar por entrada.
3.​ Análise da Resposta: O script verifica o código de saída do nc. Se for 0, a
conexão foi bem-sucedida. A resposta (se houver alguma antes do fechamento
da conexão) é capturada.
4.​ Recomendação: O script corretamente aponta que nmap -sV é geralmente mais
eficaz para a identificação de versões de serviço.
5.​ Comentário sobre psql: Inclui um exemplo comentado de como o cliente psql
poderia ser usado para obter a versão se houvesse acesso e credenciais, o que
seria uma forma mais direta de interação com o PostgreSQL.Para outros serviços como Redis ou Kafka, abordagens similares podem ser usadas
(e.g., enviar INFO para Redis, ou tentar uma conexão de metadados para Kafka), mas
ferramentas especializadas ou nmap -sV são frequentemente mais confiáveis para a
enumeração de versões.
7.2.3. Automação de Verificações de Configurações Incorretas Comuns
Scripts Bash podem automatizar a verificação de algumas configurações incorretas.
Exemplo de Script (Verificar Permissões de Arquivos Sensíveis - Conceitual):
Bash
#!/bin/bash​
​
# Script para verificar permissões de arquivos/diretórios sensíveis em um nó Atous​
# Este script precisaria ser executado NO PRÓPRIO NÓ ATUOUS ou ter acesso SSH.​
# Para um pentest externo, isso seria verificado após obter acesso.​
​
echo "[*] Verificando permissões de arquivos/diretórios sensíveis..."​
​
FILES_TO_CHECK=(​
"/etc/atous/atous_config.yml"# Arquivo de configuração principal da Atous​
"/opt/atous/keystore.p12"# Exemplo de keystore PQC​
"/var/log/atous/"
"/etc/mysql/my.cnf"
# Diretório de logs da Atous​
# Configuração MySQL, se local​
# Adicionar outros arquivos/diretórios relevantes para a Atous​
)​
​
PROBLEMS_FOUND=0​
​
for item in "${FILES_TO_CHECK[@]}"; do​
if [! -e "$item" ]; then​
echo "[INFO] Item não encontrado: $item (Pode não ser aplicável a este nó)"​
continue​
fi​
​
PERMISSIONS=$(stat -c "%a %U %G" "$item")​echo "[INFO] Permissões para $item: $PERMISSIONS"​
​
# Exemplo de verificação: Arquivos de configuração não devem ser world-writable​
if [ -f "$item" ]; then​
if [[ "$(stat -c '%A' "$item")" == *"w"* && "$(stat -c '%a' "$item")" == *"2"* && "$(stat -c '%a'
"$item")"!= "???2" ]]; then # Verifica o bit de escrita para 'others'​
# Esta lógica de permissão pode precisar de refinamento.​
# stat -c '%a' retorna permissões numéricas (e.g., 640)​
# O último dígito se refere a 'others'. Se for 2, 3, 6, ou 7, 'others' têm permissão de escrita.​
last_digit_perms=$(stat -c '%a' "$item" | cut -c3)​
if [[ "$last_digit_perms" == "2" |​
| "$last_digit_perms" == "3" |​
| "$last_digit_perms" == "6" |​
| "$last_digit_perms" == "7" ]]; then​
echo " $item é world-writable! ($PERMISSIONS)"​
PROBLEMS_FOUND=$((PROBLEMS_FOUND + 1))​
fi​
fi​
fi​
​
# Exemplo de verificação: Diretório de logs não deve ser world-readable/writable de forma excessiva​
# (A lógica exata depende da política de segurança)​
done​
​
if; then​
echo "[-] $PROBLEMS_FOUND problemas de permissão encontrados."​
exit 1​
else​
echo "[+] Nenhuma permissão excessiva óbvia encontrada nos itens verificados."​
exit 0​
fi​
Explicação Passo a Passo do Script Bash:
1.​ FILES_TO_CHECK: Um array contendo caminhos para arquivos e diretórios
sensíveis que são relevantes para a Atous. Esta lista deve ser customizada.
2.​ Loop de Verificação: O script itera sobre cada item.
3.​ Existência do Item: Verifica se o arquivo/diretório existe.
4.​ Obtenção de Permissões: stat -c "%a %U %G" "$item" obtém as permissões
numéricas (e.g., 640), o proprietário e o grupo.5.​ Lógica de Verificação (Exemplo):
○​ Para arquivos, verifica se são "world-writable" (qualquer um pode escrever).
A lógica stat -c '%a' "$item" | cut -c3 extrai o dígito de permissão para
"outros" e verifica se ele inclui permissão de escrita.
○​ Lógicas similares podem ser adicionadas para outras verificações (e.g.,
arquivos de chave privada com permissões muito abertas, diretórios de log
com permissões incorretas).
6.​ Contagem de Problemas: Mantém uma contagem de problemas encontrados e
sai com um código de status apropriado.
Importante: Este tipo de script é mais eficaz quando executado no próprio sistema
alvo ou com acesso privilegiado. Para um pentest externo, essas verificações
geralmente ocorrem após a obtenção de algum nível de acesso ao sistema.
7.3. Scripts Python para Pentesting Avançado e Automação
Python, com bibliotecas como requests para interações HTTP e pytest para
organização de testes, é excelente para criar scripts de pentesting mais complexos e
automatizados.
7.3.1. Fuzzing de Endpoints de API e Descoberta de Vulnerabilidades
Fuzzing envolve enviar uma grande quantidade de dados inválidos, inesperados ou
aleatórios para as entradas de uma aplicação para ver se ela falha, se comporta de
forma anômala ou revela vulnerabilidades.
Exemplo de Script (Fuzzing Simples de Parâmetro de API com Pytest e
Requests):
Python
# test_api_fuzzing_atous.py​
import pytest​
import requests​
import time​
import os​
import json​
​
# Configuração da API Atous​ATOUS_API_BASE_URL = os.getenv("ATOUS_API_BASE_URL", "http://localhost:80​
Works cited
1.​ Rede Atous_ Código e Análise_.pdf
2.​ OWASP Top-10 2021. Statistics-based proposal. - Wallarm, accessed June 9,
2025,
https://lab.wallarm.com/owasp-top-10-2021-proposal-based-on-a-statistical-dat
a/
3.​ OWASP Cheat Sheet Series, accessed June 9, 2025,
https://owasp.org/www-project-cheat-sheets/
4.​ OWASP Top 10:2021, accessed June 9, 2025, https://owasp.org/Top10/
5.​ OWASP Developer Guide | ASVS requirements, accessed June 9, 2025,
https://owasp.org/www-project-developer-guide/release-ja/requirements/asvs/
6.​ OWASP Application Security Verification Standard (ASVS), accessed June 9, 2025,
https://nest.owasp.org/projects/application-security-verification-standard
7.​ OWASP ZAP API - PublicAPI, accessed June 9, 2025,
https://publicapi.dev/owasp-zap-api
8.​ Documentation - ZAP, accessed June 9, 2025, https://www.zaproxy.org/docs/
9.​ OWASP Dependency-Check, accessed June 9, 2025,
https://owasp.org/www-project-dependency-check/
10.​OWASP Dependency-Check - Jenkins Plugins, accessed June 9, 2025,
https://plugins.jenkins.io/dependency-check-jenkins-plugin/
11.​ Threat Modeling - OWASP Cheat Sheet Series, accessed June 9, 2025,
https://cheatsheetseries.owasp.org/cheatsheets/Threat_Modeling_Cheat_Sheet.h
tml
12.​OWASP Top Security Risks & Vulnerabilities 2021 Edition - Sucuri, accessed June
9, 2025, https://sucuri.net/guides/owasp_top_10_2021_edition/
13.​Standard : OWASP Cheat Sheets : Access Control Cheat Sheet - OpenCRE,
accessed June 9, 2025,
https://www.opencre.org/node/standard/OWASP%20Cheat%20Sheets/section/A
ccess%20Control%20Cheat%20Sheet
14.​Access Control · OWASP Cheat Sheet Series, accessed June 9, 2025,
https://jcarpizo.github.io/owasp-info/cheatsheets/Access_Control_Cheat_Sheet.ht
ml
15.​OWASP Top 10: Cheat Sheet of Cheat Sheets - Oligo Security, accessed June 9,
2025,
https://www.oligo.security/academy/owasp-top-10-cheat-sheet-of-cheat-sheets
16.​REST Security - OWASP Cheat Sheet Series, accessed June 9, 2025,
https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html
17.​Authentication · OWASP Cheat Sheet Series, accessed June 9, 2025,
https://jcarpizo.github.io/owasp-info/cheatsheets/Authentication_Cheat_Sheet.ht
ml
18.​JSON Web Token for Java - OWASP Cheat Sheet Series, accessed June 9, 2025,
https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html
19.​SCA Vs SAST Vs DAST – Which Is Right For The Organization? - Checkmarx,
accessed June 9, 2025, https://checkmarx.com/learn/sca/sca-sast-dast/
20.​IAST vs. SAST Tool Comparison - Contrast Security, accessed June 9, 2025,
https://www.contrastsecurity.com/glossary/iast-vs-sast
21.​A Comprehensive Comparison of SAST Tools - SonarQube vs Snyk -
JinalDesai.com, accessed June 9, 2025,
https://jinaldesai.com/a-comprehensive-comparison-of-sast-tools-sonarqube-vs
-snyk/
22.​SAST tools speed comparison: Snyk Code vs SonarQube and LGTM, accessed
June 9, 2025,
https://snyk.io/blog/sast-tools-speed-comparison-snyk-code-sonarqube-lgtm/
23.​Leveraging OWASP ZAP to Automate Authenticated Scans | QBurst Blog,
accessed June 9, 2025,
https://blog.qburst.com/2024/11/leveraging-owasp-zap-to-automate-authenticat
ed-scans/
24.​dependency-check/DependencyCheck: OWASP dependency-check is a
software composition analysis utility that detects publicly disclosed vulnerabilities
in application dependencies. - GitHub, accessed June 9, 2025,
https://github.com/dependency-check/DependencyCheck
25.​How to Run an API Scanner with OWASP ZAP - Jit.io, accessed June 9, 2025,
https://www.jit.io/resources/owasp-zap/api-scanner-with-owasp-zap
26.​Ensuring API Security With OWASP ZAP: A Step-by-Step Guide | OpsMx Blog,
accessed June 9, 2025,
https://www.opsmx.com/blog/ensuring-api-security-with-owasp-zap-a-step-by-
step-guide/
27.​Scanning APIs with ZAP, accessed June 9, 2025,
https://www.zaproxy.org/blog/2017-06-19-scanning-apis-with-zap/
28.​ZAP - Scan Hooks, accessed June 9, 2025,
https://www.zaproxy.org/docs/docker/scan-hooks/
29.​Check Component Vulnerabilities Using OWASP Dependency-Check | Baeldung,
accessed June 9, 2025,
https://www.baeldung.com/java-maven-owasp-dependency-check
30.​How to Use OWASP Dependency Check in a Maven Project, accessed June 9,
2025,
https://www.albinsblog.com/2025/01/how-to-use-owasp-dependency-check-in-
maven-projec.html
31.​OWASP Dependency Check Maven Plugin - Stack Overflow, accessed June 9,
2025,
https://stackoverflow.com/questions/79418320/owasp-dependency-check-mave
n-plugin
32.​Authorize HttpServletRequests :: Spring Security, accessed June 9, 2025,
https://docs.spring.io/spring-security/reference/servlet/authorization/authorize-ht
tp-requests.html
33.​18.1 Testing Method Security - Spring, accessed June 9, 2025,https://docs.spring.io/spring-security/site/docs/5.2.x/reference/html/test.html

Guia Abrangente de MySQL: Do Básico ao Avançado com
Otimização e Modelagem de Dados para a Rede Atous
Parte 1: Dominando o MySQL: Dos Fundamentos à Otimização
Avançada
Capítulo 1: Introdução ao MySQL e Bancos de Dados Relacionais
Visão Geral do MySQL
O MySQL é um sistema de gerenciamento de banco de dados (SGBD) proeminente,
projetado para armazenar dados de forma estruturada e organizada. Funciona como
um servidor robusto, capaz de lidar com grandes volumes de informação, sendo
reconhecido por sua velocidade, confiabilidade, escalabilidade e facilidade de uso.
Essas características o tornam adequado tanto para utilitários independentes quanto
como um componente integral de aplicações complexas.1 O MySQL opera
predominantemente em um modelo cliente/servidor, mas também pode ser
incorporado em sistemas embarcados. No seu cerne, utiliza a Linguagem de Consulta
Estruturada (SQL), que é o padrão universal para acessar e manipular bancos de
dados relacionais.1 Um dos fatores significativos para sua ampla adoção é sua
natureza de código aberto, permitindo que qualquer pessoa utilize e modifique o
software sem custos de licenciamento.1
A natureza de código aberto e a consequente adoção massiva do MySQL resultaram
em um ecossistema vasto e vibrante. Este ecossistema inclui uma pletora de
ferramentas, desde interfaces gráficas de administração até bibliotecas de
conectividade para diversas linguagens de programação. Além disso, uma
comunidade global ativa contribui com documentação extensa, fóruns de discussão,
blogs técnicos e soluções para uma miríade de desafios. Para um projeto como a
"Rede Atous", a escolha do MySQL como um repositório de dados traz consigo a
vantagem de um risco reduzido e potencial diminuição nos custos de
desenvolvimento e operacionais. A ausência de taxas de licenciamento para a versão
comunitária do produto principal impacta diretamente os custos. A abundância de
recursos gratuitos facilita a resolução de problemas e o aprendizado contínuo da
equipe. Adicionalmente, a disponibilidade de um grande contingente de profissionais
qualificados em MySQL simplifica a contratação e a formação de equipes de
desenvolvimento e manutenção, fatores que contribuem para a viabilidade e
sustentabilidade de longo prazo do projeto.
O design intrínseco do MySQL, focado em velocidade e confiabilidade, juntamente
com sua capacidade de escalonamento – desde configurações modestas emdesktops até clusters de servidores de alta performance 1 – o posiciona como um
candidato viável para ambientes de produção exigentes. A "Rede Atous", com seu
objetivo de "tolerância zero a falhas" 2, necessita de uma fundação de dados que
possa garantir alta disponibilidade e resiliência. Embora não detalhados
exaustivamente nos materiais de pesquisa fornecidos, recursos padrão do MySQL,
como replicação e clustering (por exemplo, InnoDB Cluster), seriam essenciais para
atender a tais requisitos rigorosos de disponibilidade. A capacidade de escalar
horizontal e verticalmente também significa que o MySQL pode acompanhar o
crescimento das necessidades da rede, adaptando-se a volumes de dados e cargas
de transação crescentes.
Conceitos de Bancos de Dados Relacionais
Bancos de dados relacionais, como o MySQL, armazenam dados em tabelas
separadas, em vez de consolidar todas as informações em um único repositório
massivo. As estruturas do banco de dados são organizadas em arquivos físicos
otimizados para velocidade de acesso. O modelo lógico, que compreende objetos
como bancos de dados, tabelas, visões (views), linhas e colunas, oferece um
ambiente de programação flexível. Neste modelo, são estabelecidas regras que
governam os relacionamentos entre diferentes campos de dados, como
relacionamentos um-para-um, um-para-muitos, unicidade, obrigatoriedade ou
opcionalidade de campos, e "ponteiros" (chaves estrangeiras) entre tabelas distintas.
O próprio sistema de banco de dados é responsável por impor essas regras,
garantindo que, com um design de banco de dados bem elaborado, a aplicação
nunca encontre dados inconsistentes, duplicados, órfãos, desatualizados ou
ausentes.1
A imposição de relacionamentos de dados e da integridade referencial pelo próprio
SGBD relacional (MySQL) é um mecanismo fundamental para prevenir a ocorrência de
anomalias de dados. Esta característica suporta diretamente o objetivo da "Rede
Atous" de manter a consistência e a confiabilidade dos dados. Quando o banco de
dados impõe regras como chaves estrangeiras, que garantem que um registro em
uma tabela que faz referência a outra tabela corresponda a um registro existente, ou
restrições de unicidade, que previnem a duplicação de identificadores, ele alivia uma
carga significativa da lógica da aplicação. Isso resulta em uma integridade de dados
mais robusta, pois as regras são aplicadas consistentemente, independentemente de
como a aplicação tenta manipular os dados. Para um sistema complexo e distribuído
como a "Rede Atous", essa integridade embutida no nível do banco de dados é um
ativo de grande valor, contribuindo para a estabilidade e a corretude geral do sistema.Configurando o Ambiente MySQL
A interação com o MySQL e seus diversos utilitários geralmente ocorre através da
linha de comando. As opções de configuração para os programas MySQL podem ser
especificadas diretamente na invocação do comando, por meio de arquivos de opção
(como my.cnf ou my.ini), ou através de variáveis de ambiente.3 Dentre os programas
essenciais, destacam-se o mysqld, que é o próprio servidor MySQL; o mysql, que é o
cliente de linha de comando para interação direta com o servidor; e o
mysql_secure_installation, um script crucial para aprimorar a segurança da instalação
inicial.3
A execução do script mysql_secure_installation 3 é um passo inicial crítico e
indispensável após a instalação do MySQL, visando mitigar vulnerabilidades de
segurança comuns. Para um sistema como a "Rede Atous", que almeja ser uma "rede
impenetrável" 2, iniciar com uma instância MySQL devidamente protegida é um
requisito fundamental. Instalações padrão do MySQL podem apresentar
configurações inseguras, como a existência de usuários anônimos, acesso root
permitido de qualquer host ou a presença de bancos de dados de teste que podem
ser explorados. O mysql_secure_installation auxilia na correção dessas brechas ao
guiar o usuário através da definição de uma senha para o usuário root, remoção de
usuários anônimos, desabilitação do login root remoto e remoção do banco de dados
de teste. Omitir esta etapa deixaria a instância MySQL exposta a riscos de segurança
conhecidos, comprometendo a postura de segurança da "Rede Atous" desde sua
fundação.
Tabela 1: Programas Essenciais do MySQL
Nome do ProgramaDescriçãoCaso de Uso Primário
mysqldO servidor MySQL.Executar o SGBD MySQL,
gerenciar dados e conexões.
mysqlO cliente de linha de comando
MySQL.Conectar-se ao servidor,
executar queries SQL, scripts.
mysqladminPrograma de administração
do servidor MySQL.Verificar status do servidor,
gerenciar processos,
usuários.
mysqldumpPrograma de backup deCriar backups lógicos debanco de dados.bancos de dados ou tabelas.
mysql_secure_installationScript para melhorar a
segurança da instalação
MySQL.Proteger a instalação inicial
do MySQL.
mysqlcheckPrograma de manutenção de
tabelas.Verificar, reparar e otimizar
tabelas.
mysqlimportPrograma de importação de
dados.Importar dados de arquivos
texto para tabelas.
mysqlbinlogUtilitário para processar
arquivos de log binário.Visualizar e aplicar alterações
de logs binários (replicação,
recuperação).
Esta tabela fornece uma referência rápida para os utilitários centrais do MySQL,
ajudando a compreender suas finalidades e como podem ser empregados na
administração e operação do banco de dados.
Capítulo 2: Fundamentos de SQL com MySQL
A Linguagem de Consulta Estruturada (SQL) é a espinha dorsal da interação com
bancos de dados relacionais como o MySQL. Seus comandos são categorizados com
base em sua funcionalidade, permitindo uma abordagem organizada para a definição,
manipulação, consulta e controle dos dados.
Data Definition Language (DDL)
Os comandos de Linguagem de Definição de Dados (DDL) são utilizados para
construir e gerenciar a estrutura dos objetos do banco de dados, como os próprios
bancos de dados e as tabelas que contêm os dados.5 Os principais comandos DDL
são:
●​ CREATE: Usado para criar novos objetos, como CREATE DATABASE
nome_do_banco; ou CREATE TABLE nome_da_tabela (coluna1 TIPO_DE_DADO,
coluna2 TIPO_DE_DADO,...);.
○​ Exemplo: CREATE TABLE account (acct_num INT, amount DECIMAL(10,2)); 7
●​ ALTER: Usado para modificar a estrutura de um objeto existente, como adicionar
uma coluna a uma tabela (ALTER TABLE nome_da_tabela ADD COLUMN
nova_coluna TIPO_DE_DADO;) ou alterar o tipo de dado de uma coluna.
●​ DROP: Usado para remover objetos do banco de dados, como DROP TABLEnome_da_tabela; ou DROP DATABASE nome_do_banco;.
A utilização correta de DDL, especialmente na definição de tipos de dados
apropriados e restrições, constitui a primeira linha de defesa para a integridade dos
dados e pode impactar significativamente a eficiência do armazenamento e o
desempenho das consultas. Para a "Rede Atous", a seleção de tipos de dados ótimos
para campos como PQCKey.keyData (que em Java é byte 2 e mapearia bem para
BLOB ou VARBINARY em MySQL para dados binários) ou NodeInfo.reputationScore
(que em Java é double 2 e mapearia para DOUBLE ou DECIMAL com precisão definida
em MySQL) é crucial.2 Escolher um VARCHAR(255) para um campo que armazenará
apenas códigos de dois caracteres, por exemplo, desperdiçaria espaço e poderia
tornar as comparações mais lentas. Da mesma forma, usar INT para um campo que
necessita de casas decimais levaria à perda de dados. Restrições como NOT NULL
previnem dados ausentes, UNIQUE garante a unicidade de valores em uma coluna,
PRIMARY KEY define o identificador único da linha, e FOREIGN KEYs mantêm a
integridade relacional entre tabelas. Essas escolhas de DDL afetam diretamente a
qualidade dos dados e o desempenho do sistema.
Data Manipulation Language (DML)
Os comandos de Linguagem de Manipulação de Dados (DML) são usados para
adicionar, modificar e remover dados dentro das tabelas.5 Os comandos DML
fundamentais são:
●​ INSERT: Adiciona novas linhas (registros) a uma tabela.
○​ Sintaxe: INSERT INTO nome_da_tabela (coluna1, coluna2,...) VALUES (valor1,
valor2,...);
○​ Exemplo: INSERT INTO account VALUES(137,14.98),(141,1937.50),(97,-100.00); 7
●​ UPDATE: Modifica dados existentes em linhas de uma tabela.
○​ Sintaxe: UPDATE nome_da_tabela SET coluna1 = valor1, coluna2 = valor2,...
WHERE condicao;
○​ Exemplo: UPDATE Employees SET Salary = Salary * 1.1 WHERE Department =
'Engineering'; 5
●​ DELETE: Remove linhas de uma tabela.
○​ Sintaxe: DELETE FROM nome_da_tabela WHERE condicao;
A eficiência das operações DML pode ser fortemente influenciada pela presença de
índices e triggers. Índices, embora acelerem consultas SELECT, podem tornar
operações DML mais lentas, pois os próprios índices precisam ser atualizados.
Triggers adicionam uma sobrecarga, pois executam SQL adicional em resposta a
eventos DML. Grandes inserções em lote (INSERT INTO... VALUES (...), (...),...) sãogeralmente mais performáticas do que múltiplas instruções INSERT de uma única
linha devido à redução de overhead de transação e comunicação com o servidor. É
crucial que as instruções UPDATE e DELETE utilizem cláusulas WHERE específicas
para evitar modificações ou exclusões acidentais em toda a tabela. Para a "Rede
Atous", onde entidades como NodeInfo.status ou NodeInfo.reputationScore 2 podem
ser atualizadas com frequência, o impacto no desempenho DML devido a índices e
triggers nessas tabelas precisa ser cuidadosamente considerado e testado.
Data Query Language (DQL)
A Linguagem de Consulta de Dados (DQL) consiste primariamente no comando
SELECT, que é usado para recuperar dados das tabelas do banco de dados.5 É, sem
dúvida, o comando SQL mais utilizado.
●​ SELECT: Recupera dados de uma ou mais tabelas.
○​ Sintaxe básica: SELECT coluna1, coluna2,... FROM nome_da_tabela;
○​ Para selecionar todas as colunas: SELECT * FROM nome_da_tabela;
○​ Cláusulas comuns com SELECT:
■​ WHERE condicao: Filtra as linhas com base em uma condição.
■​ Exemplo: SELECT * FROM Customers WHERE City = 'New York'; 5
■​ ORDER BY coluna(s): Ordena o conjunto de resultados.
■​ GROUP BY coluna(s): Agrupa linhas que têm os mesmos valores em
colunas especificadas em linhas de resumo. Frequentemente usado com
funções de agregação (COUNT, SUM, AVG, MAX, MIN).
■​ HAVING condicao: Filtra grupos criados pela cláusula GROUP BY.
■​ LIMIT numero_de_linhas: Restringe o número de linhas retornadas.
■​ Exemplo: SELECT name, email FROM customers WHERE customer_id =
123; 8 (implícito que LIMIT 1 seria usado se customer_id é PK).
A DQL eficaz não se resume a obter os dados corretos, mas também a obtê-los de
maneira eficiente. A escolha das colunas na cláusula SELECT (evitar SELECT * para
melhor desempenho, selecionando apenas as colunas necessárias 8), a estrutura das
cláusulas WHERE (para permitir o uso de índices) e a compreensão de como GROUP
BY opera são fundamentais para a otimização de consultas. O uso indiscriminado de
SELECT * recupera todas as colunas da tabela, o que pode levar a uma sobrecarga
desnecessária de E/S (Entrada/Saída) de disco e de tráfego de rede, especialmente
se apenas um subconjunto das colunas for realmente necessário para a aplicação.
Cláusulas WHERE mal construídas, como aplicar funções a colunas indexadas, podem
impedir que o otimizador do MySQL utilize índices, resultando em varreduras
completas da tabela (full table scans). Operações de GROUP BY podem ser intensivas
em recursos, especialmente em tabelas grandes, se não forem acompanhadas porcondições de filtragem adequadas ou se os agrupamentos forem feitos em colunas
de alta cardinalidade sem o suporte de índices.
Data Control Language (DCL) & Transaction Control Language (TCL)
●​ Data Control Language (DCL): Gerencia os direitos de acesso e permissões no
banco de dados.5
○​ GRANT: Concede permissões a usuários ou roles (funções). Ex: GRANT
SELECT, INSERT ON nome_da_tabela TO 'usuario'@'host';
○​ REVOKE: Remove permissões. Ex: REVOKE INSERT ON nome_da_tabela FROM
'usuario'@'host';
A DCL é fundamental para proteger o banco de dados da "Rede Atous". O
princípio do menor privilégio deve ser rigorosamente aplicado, concedendo aos
usuários e às roles da aplicação apenas as permissões estritamente necessárias
para suas funções. Diferentes componentes da "Rede Atous" (por exemplo, o
sistema ABISS, um nó P2P, o agendador de tarefas) provavelmente exigirão níveis
distintos de acesso ao banco de dados. Conceder privilégios excessivos, como
SUPER ou ALL PRIVILEGES, a usuários de aplicação representa um risco de
segurança significativo. A DCL permite um controle granular (por exemplo,
permissão de SELECT em tabelas específicas, INSERT em outras). Para a "Rede
Atous", o serviço de aplicação que lida com submissões de tarefas pode
necessitar de permissão de INSERT na tabela TaskDefinition, enquanto um
serviço de monitoramento pode requerer apenas SELECT em várias tabelas. Essa
segregação de privilégios minimiza o dano potencial caso um componente da
aplicação seja comprometido.
●​ Transaction Control Language (TCL): Gerencia transações para garantir a
consistência dos dados.5 Uma transação é uma sequência de uma ou mais
operações SQL executadas como uma única unidade atômica de trabalho.
○​ START TRANSACTION (ou BEGIN): Inicia uma nova transação.
○​ COMMIT: Torna permanentes todas as alterações de dados feitas durante a
transação atual.
○​ ROLLBACK: Desfaz todas as alterações de dados feitas durante a transação
atual.
○​ SAVEPOINT nome_do_ponto: Define um ponto de salvamento dentro da
transação atual.
○​ ROLLBACK TO SAVEPOINT nome_do_ponto: Desfaz as alterações feitas após
o ponto de salvamento especificado.
A TCL é vital para operações que devem ser atômicas, ou seja, ou todas são
concluídas com sucesso, ou nenhuma delas é. Um exemplo na "Rede Atous" é o
SubmitTaskUseCase, que pode persistir uma tarefa no banco de dados e, em seguida,
publicar um evento em um sistema de mensageria como Kafka.2 Se essas duas
operações fizerem parte de uma transação, o COMMIT as tornará permanentesjuntas. Se a publicação do evento falhar, um ROLLBACK pode desfazer a persistência
da tarefa, mantendo o sistema em um estado consistente. Se o SubmitTaskUseCase
salvar uma TaskDefinition no MySQL e subsequentemente falhar ao publicar um
evento no Kafka, sem uma transação, a tarefa existirá no banco de dados, mas o
restante do sistema (que depende do evento) não terá conhecimento dela. Com uma
transação, se a publicação no Kafka falhar, a inserção no banco de dados pode ser
revertida, mantendo o estado do sistema consistente. Este mecanismo é crucial para
alcançar o objetivo de "tolerância zero a falhas" da "Rede Atous".2
Tabela 2: Categorias de Comandos SQL
CategoriaForma CompletaPropósitoComandos de
Exemplo
DDLData Definition
LanguageDefinir ou modificar a
estrutura de objetos
do banco de dadosCREATE, ALTER,
DROP
DMLData Manipulation
LanguageInserir, atualizar ou
excluir dados nas
tabelasINSERT, UPDATE,
DELETE
DQLData Query
LanguageRecuperar dados do
banco de dadosSELECT
DCLData Control
LanguageControlar o acesso
aos dados e ao
banco de dadosGRANT, REVOKE
TCLTransaction Control
LanguageGerenciar transações
de banco de dadosCOMMIT, ROLLBACK,
SAVEPOINT
Esta tabela fornece uma visão geral clara e de alto nível dos tipos de comandos SQL,
essencial para que iniciantes compreendam a estrutura da linguagem e as diferentes
operações que podem realizar.
Capítulo 3: Técnicas Avançadas de Consulta SQL
Dominar os fundamentos do SQL é apenas o começo. Para extrair informações
complexas e realizar análises sofisticadas, é necessário empregar técnicas de
consulta mais avançadas.Joins Complexos (INNER, LEFT, RIGHT, FULL OUTER)
As operações de JOIN são fundamentais em bancos de dados relacionais, pois
permitem combinar linhas de duas ou mais tabelas com base em uma coluna
relacionada entre elas. A indexação das colunas utilizadas nas cláusulas de JOIN é
crucial para o desempenho.9
●​ INNER JOIN: Retorna apenas as linhas que têm correspondência em ambas as
tabelas.​
SQL​
SELECT A.coluna1, B.coluna2​
FROM TabelaA A​
INNER JOIN TabelaB B ON A.chave_comum = B.chave_comum;​
●​ LEFT JOIN (ou LEFT OUTER JOIN): Retorna todas as linhas da tabela à
esquerda (TabelaA) e as linhas correspondentes da tabela à direita (TabelaB). Se
não houver correspondência na tabela à direita, as colunas da tabela à direita
terão valor NULL.​
SQL​
SELECT A.coluna1, B.coluna2​
FROM TabelaA A​
LEFT JOIN TabelaB B ON A.chave_comum = B.chave_comum;​
●​ RIGHT JOIN (ou RIGHT OUTER JOIN): Retorna todas as linhas da tabela à
direita (TabelaB) e as linhas correspondentes da tabela à esquerda (TabelaA). Se
não houver correspondência na tabela à esquerda, as colunas da tabela à
esquerda terão valor NULL.​
SQL​
SELECT A.coluna1, B.coluna2​
FROM TabelaA A​
RIGHT JOIN TabelaB B ON A.chave_comum = B.chave_comum;​
●​ FULL OUTER JOIN: Retorna todas as linhas de ambas as tabelas. Se houver uma
correspondência entre as tabelas, as colunas de ambas são preenchidas. Se não
houver correspondência para uma linha de uma das tabelas, as colunas da outra
tabela terão valor NULL. (Nota: MySQL não suporta FULL OUTER JOIN
diretamente; ele pode ser simulado usando LEFT JOIN UNION RIGHT JOIN).
A ordem das tabelas em JOINs e a presença de índices nas chaves de junção podem
alterar drasticamente o desempenho da consulta. O otimizador do MySQL tenta
encontrar a melhor ordem de junção, mas compreender esse processo ajuda aescrever consultas melhores e a criar índices eficazes.8 Por exemplo, juntar uma
tabela muito grande a uma tabela pequena pode ser mais eficiente se a tabela
pequena for processada primeiro para filtrar as linhas necessárias da tabela grande.
Índices nas colunas usadas nas cláusulas ON permitem que o MySQL encontre
rapidamente linhas correspondentes, evitando, sempre que possível, junções de loop
aninhado sobre tabelas inteiras. Para a "Rede Atous", junções entre TaskDefinition e
NodeInfo (para obter detalhes do nó submissor) ou entre BlockRecord e
TransactionRecord serão operações comuns que se beneficiarão de JOINs
otimizados.
Subconsultas (Escalares, Multi-linhas, Correlacionadas)
Subconsultas (subqueries) são consultas aninhadas dentro de outra consulta SQL.
Elas podem retornar um único valor (escalar), múltiplas linhas, ou podem ser
correlacionadas, o que significa que referenciam colunas da consulta externa.10
●​ Subconsulta Escalar: Retorna um único valor. Pode ser usada onde uma
expressão de valor único é esperada.​
SQL​
SELECT nome_produto, preco, (SELECT AVG(preco) FROM Produtos) AS preco_medio​
FROM Produtos;​
●​ Subconsulta Multi-linhas: Retorna um conjunto de linhas, frequentemente
usado com operadores como IN, ANY, ALL.​
SQL​
SELECT nome_cliente​
FROM Clientes​
WHERE id_cliente IN (SELECT id_cliente FROM Pedidos WHERE data_pedido >
'2023-01-01');​
●​ Subconsulta Correlacionada: Uma subconsulta que depende da consulta
externa para seus valores. Ela é executada repetidamente, uma vez para cada
linha que pode ser selecionada pela consulta externa.​
SQL​
SELECT e1.nome_empregado, e1.salario​
FROM Empregados e1​
WHERE e1.salario > (SELECT AVG(salario) FROM Empregados e2 WHERE
e2.departamento_id = e1.departamento_id);​
Neste exemplo, a subconsulta calcula o salário médio para o departamento do
empregado da consulta externa.Embora as subconsultas sejam uma ferramenta poderosa, elas podem, muitas vezes,
ser reescritas como JOINs ou Expressões de Tabela Comuns (CTEs) para melhor
desempenho e legibilidade. Isso é especialmente verdadeiro para subconsultas
correlacionadas, que podem ser muito ineficientes, pois podem ser executadas uma
vez para cada linha da consulta externa.8 Otimizadores modernos de bancos de
dados estão cada vez melhores em lidar com subconsultas, mas historicamente,
reescrevê-las como JOINs frequentemente resultava em planos de execução mais
eficientes. As CTEs, em particular, oferecem uma maneira mais limpa e estruturada de
decompor a lógica complexa que anteriormente seria tratada por subconsultas
convolutas.
Expressões de Tabela Comuns (CTEs)
Expressões de Tabela Comuns (CTEs), definidas com a palavra-chave WITH, criam
conjuntos de resultados nomeados temporários que podem ser referenciados dentro
de uma única instrução SQL. Elas melhoram a legibilidade e podem simplificar
consultas complexas, incluindo consultas recursivas.10 O MySQL suporta CTEs a partir
da versão 8.0.
●​ CTE Não Recursiva: Usada para dividir consultas complexas em partes lógicas
mais simples.​
SQL​
WITH VendasPorRegiao AS (​
SELECT regiao, SUM(total_venda) AS total_vendas_regiao​
FROM Vendas​
GROUP BY regiao​
),​
TopRegioes AS (​
SELECT regiao, total_vendas_regiao​
FROM VendasPorRegiao​
WHERE total_vendas_regiao > 100000​
)​
SELECT T.regiao, T.total_vendas_regiao, C.nome_gerente_regional​
FROM TopRegioes T​
JOIN ContatosRegionais C ON T.regiao = C.regiao;​
​
Este exemplo, WITH Supervisors AS ( SELECT e.employee_id, e.employee_name,
s.supervisor_name FROM employees e LEFT JOIN employees s ON
e.supervisor_id = s.employee_id ) SELECT employee_id, employee_name,
supervisor_name FROM Supervisors; 12, ilustra como uma CTE pode simplificar aobtenção de informações de supervisores.
●​ CTE Recursiva: Usada para consultar dados hierárquicos, como organogramas
ou listas de materiais.​
SQL​
WITH RECURSIVE HierarquiaEmpregados (id_empregado, nome_empregado,
id_gerente, nivel) AS (​
SELECT id_empregado, nome_empregado, id_gerente, 0 AS nivel​
FROM Empregados​
WHERE id_gerente IS NULL -- Ponto de partida: empregados sem gerente (topo da
hierarquia)​
UNION ALL​
SELECT e.id_empregado, e.nome_empregado, e.id_gerente, h.nivel + 1​
FROM Empregados e​
INNER JOIN HierarquiaEmpregados h ON e.id_gerente = h.id_empregado​
)​
SELECT id_empregado, nome_empregado, nivel​
FROM HierarquiaEmpregados​
ORDER BY nivel, id_empregado;​
As CTEs permitem que os desenvolvedores definam blocos de construção lógicos
dentro de uma consulta, tornando o SQL complexo muito mais fácil de entender e
manter em comparação com subconsultas profundamente aninhadas ou múltiplas
visualizações (views).10 Em vez de uma consulta monolítica com muitas partes
aninhadas, as CTEs permitem uma definição passo a passo de resultados
intermediários. Cada CTE possui um nome, tornando seu propósito mais claro. Essa
modularidade dentro de uma consulta é um benefício significativo para tarefas
analíticas complexas. Embora não explicitamente mencionado nos documentos da
"Rede Atous", se existissem relacionamentos hierárquicos (por exemplo, tarefas tendo
subtarefas, ou uma cadeia de referência para nós), as CTEs recursivas seriam a
maneira padrão em SQL para consultar tais estruturas. Por exemplo, se TaskDefinition
pudesse ter um parent_task_id, consultar toda a hierarquia de uma tarefa exigiria
recursão, e as CTEs recursivas forneceriam uma maneira elegante de percorrer tais
relacionamentos pai-filho.
Funções de Janela para Consultas Analíticas
As funções de janela (window functions) realizam cálculos em um conjunto de linhas
da tabela que estão de alguma forma relacionadas à linha atual. Elas são usadas para
classificação (ranking), médias móveis, somas cumulativas, etc., sem colapsar aslinhas como faz a cláusula GROUP BY.10 A sintaxe principal envolve a cláusula OVER(),
que pode incluir PARTITION BY para dividir as linhas em grupos e ORDER BY para
ordenar as linhas dentro de cada partição.
●​ Funções de Classificação:
○​ ROW_NUMBER() OVER (PARTITION BY... ORDER BY...): Atribui um número
sequencial único a cada linha dentro de sua partição.
■​ Exemplo para encontrar registros duplicados: ROW_NUMBER() OVER
(PARTITION BY email ORDER BY email) AS ROWNUM.13
○​ RANK() OVER (PARTITION BY... ORDER BY...): Atribui uma classificação a cada
linha dentro de sua partição, com empates recebendo a mesma classificação
e a próxima classificação sendo pulada.
○​ DENSE_RANK() OVER (PARTITION BY... ORDER BY...): Similar ao RANK(), mas
os empates recebem a mesma classificação e a próxima classificação não é
pulada.
●​ Funções de Valor/Deslocamento:
○​ LEAD(coluna, deslocamento, valor_padrao) OVER (PARTITION BY... ORDER
BY...): Acessa dados de uma linha subsequente dentro da partição.
○​ LAG(coluna, deslocamento, valor_padrao) OVER (PARTITION BY... ORDER
BY...): Acessa dados de uma linha anterior dentro da partição.
●​ Funções Agregadas de Janela:
○​ SUM(coluna) OVER (PARTITION BY... ORDER BY... [frame_clause]): Calcula a
soma cumulativa ou móvel.
○​ AVG(coluna) OVER (PARTITION BY... ORDER BY... [frame_clause]): Calcula a
média cumulativa ou móvel.
○​ COUNT(coluna) OVER (PARTITION BY... ORDER BY... [frame_clause]): Conta
linhas dentro da janela.
As funções de janela podem ser extremamente poderosas para analisar os dados da
"Rede Atous". Por exemplo, poderiam ser usadas para classificar nós por
reputationScore dentro de certas capabilities 2, calcular a média móvel das taxas de
submissão de tarefas, ou encontrar o estado anterior/seguinte de uma tarefa. Para
encontrar os 3 nós com maior pontuação de reputação para cada capacidade, uma
consulta como SELECT *, ROW_NUMBER() OVER (PARTITION BY capability ORDER BY
reputationScore DESC) as rn FROM NodeInfo WHERE rn <= 3; (conceitualmente, pois
capability seria em uma tabela de junção) seria muito mais simples e frequentemente
mais performática do que usar auto-junções (self-joins) ou subconsultas complexas.
A análise de tendências em dados de SecurityEvent (por exemplo, taxa de tipos de
eventos específicos ao longo do tempo) também poderia alavancar funções de janela.Tabela 3: Funções de Janela Comuns
Nome da FunçãoDescriçãoCaso de Uso Típico
ROW_NUMBER() OVER(...)Atribui um inteiro sequencial
único para cada linha dentro
de sua partição.Paginação, identificação de
duplicatas, seleção de N
primeiros por grupo.
RANK() OVER(...)Atribui uma classificação a
cada linha dentro de sua
partição; empates recebem a
mesma classificação, pulando
a próxima.Classificação de vendas,
pontuações, onde empates
são tratados e afetam a
próxima classificação.
DENSE_RANK() OVER(...)Similar ao RANK(), mas não
pula classificações após
empates.Classificações onde uma
sequência contínua é
desejada apesar dos
empates.
LEAD(coluna, offset) OVER(...)Acessa o valor da coluna de
