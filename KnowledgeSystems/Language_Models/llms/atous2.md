[
  {
    "header": {
      "version": 1,
      "block_number": 0,
      "previous_hash": "0000000000000000000000000000000000000000000000000000000000000000",
      "merkle_root": "0000000000000000000000000000000000000000000000000000000000000000",
      "timestamp": "2025-06-02T19:15:16.475699555Z",
      "validator": {
        "method": "atous",
        "identifier": "atous-node-1",
        "public_key_hash": "1e34eacfae35e0cdb64e3275caa0a2fdbb9d978e6da350878780f9268ff28290"
      },
      "extra": {}
    },
    "transactions": [],
    "signature": "M3/2CLOCW94pKzTZBZnACYB0M5Pil9XFpiDRe5x3DuA6J6v/WCAjJoi32eSWMcI4hv4VN13F29fkFzRrl5qiezenBni5YtYMFVCBB1Lbb5X980m9wR/wC2hPfDUDulwiHQGXhWaAGGVrKKB9IsefRNUXta0ZpkKbAnYjLIt5+wNFsh16GSmrEYMvTaMkIfqE25cssUcKkpOHo5np3k0YeUUQfeYbmUq24kUA6Msu6w0DYHRVLJNH+OZmsCOND2sSSFHH+sC6JgVUbYtcdtgwMaG4x/OwYlkfLXn9AQP8c9d5PLxk6LxRDHLeAd6TOMStMNPE2hffhp8S2FyYYZQwiPzXzsfIxwsKOMfdYgCMVsvpNtCsMQicR0jmyCoBc0htukfRW78rcAzO/aSN18fyG2UcyLVnykC3KtLSMkj3usJr55BNVCqTYLTPBEteOXcbEEBX8tdBQz8ohFD/weKwvEsYRX5tyClvbFWqxsJxEz9gnYzk91CqToD62VYb3pOUTKpJ2I4Ksr5oqlFFOCHjcFGUODptjVLa8ZfLpfPJ8VXB+GHKLvux5Tryc5EVP/AohAw+mGmdJF31wS8oYDwBcs2+/mIdrUMhe9crjIQkvqX+szd2E7fDBW4cSjDkB7vX+WAxu/Z2kD6GBO369xKmPPlI3G754X0arPq4ZHPnZQ8WQKqnC9xQEb9CpeJYJzM+THhLgjBViTxCOOwG0Mm0IrM2jeaCIoAyhCuUP/Q3saIbB8FSySzi5vQBU2uF1t7ESClkcCM+Un+bpCjEkez5g4fjdKCzh/Q1O84WZjUyJbsh0HgTrYkSWzbbgXujUoqm8Su576QgkHG3uuRWXruzRJ/J0Mqfjo0ubPB+sCM7cuOFM4D8JJHRSV/1re9f/j7nG05W3pZOqS7EfCu+fBDYv+FxKJPp1SB5jEfhwqPAo9IdUqf3Jjxg4q+F8zgUA/atM/nwpVRCRItAgrklkT59ETAFqm4Ni6EcMEDsT3xQoEggdrAqpdTItHvEpehzST9d7WWlrNGci99PsFeKmGWiHjsZy02yvug3bfGxtYLXlfhXBDH9NT6eu2F9eO4wTzSwPSkugu522f1SGVj8RuvBCwFXRcXMJ8XGrppi9zTdYb32lTTYWJo6P/W4thw5x5Blu0FzqOALJsCyNcG0pAulqk+km3eyGG8MZZ8PANs8N06NEzsymdCQYrhZNfO/KcAHbPMNtUQVVx+YUmatQ4zY2FEai8AoYLaRzIkhbV7RVcfUrycy8B/prKTCmY72xrrWMHrqzfAb7Q6IM6iB1ewlFnDHZEHjVf8QxTCYVp3qyITz9iMg8wYp6okNznCevw8VSL471/1SsTKc7vjlSrO6YlKZ4BYQ6D/h5s67aUAXcIsU+PpbjKkgDaubeV1iKMJvB2pvuIOioicRVjnAb0PH/iPky4y/+1BTCvMTOXIBvjkhuXKegdyp41plaLWBDmCAPMB5ASztBt63sheuAzEedzDUhuochTCbrZ0oaB9+LawwSBIvry81n1873ylyhuw/Mrrhban9WtwGhnffeA5GltQG/yvrfKXbP1MIIjNfUMyblUOkgLX2lZUFqin5H5yrVMKhHRiWi2dwKjufUe3d26+eiv0ZI/yP4cLHqaUsYY+c3kNBUPcdlDLW6F7LDSX29UXVB3YBVjxJj4i7aCRVHsVMCld8a6OtRL3y14Wp4UNFAzYi8EOftclJ6+mpiHeCGOG+PYO0Klar3/2n2x5Bdzwe8X16f86+KVsv/N1QgCczu4u6rYmEnaYt1xzq5lEAyFFcrJSE7rPL6rV2SXy+TrGS+msBjTYC68ydwVBaqcR0bt9XdZqXSbDHfnRIih9R4OC6zjOsbJC4QQwm5zgK0qc6anVb3ChwaDHd3hEZlc0JR3DRHk3CV0YE04VCkLpDQJrA0BMsD+6tDmDkQww8A4iT4blDv355gm1A2AopLcO5a9Xsr5G0dgsy8f5zLnZpaN19u4I8GGTN57EwWjqYu49bIphg99yW0E5abxK7grZpO1Mg69kPLmvxrFhhMy4C6XNyqJqdVxEMPfcTwZo0gOz9gRXcwukP0UsVHoltXUrO68tCjybrBusSyj3pOjMgAUDjW+pi+WuxHr5zDkKdtcTyvzkQ0RrBzW17L59D3zUmG8MFFQWpzpLP5ifkJBN4q7nSvCRHPrEYIK586shu66lrb2BxmuYB69CPfRqDqEBTSRWjuI+U7S2hfVa9FMU00M3k7ubwOju4uuf8uQSBPBh2vcCemQ3xVmJhqWf8iVjLerevdtFx3e9raHWBH3xzkA4ODQeFv6xBYPW73dEefbhBOMqWF2sYNOGB9gIytmYlKSvBW4ErTcfGlsF4zeX4xO7gWsFEPaoe/JyDXYqjoQHxmzFNeYmX0CZAySNjZ20tq4zUjAMqZc6JudGJAyraqISgSZ/17ZKX9VP0bJepqg0EycZ9R5NuSEN7LZlsfhCuwMK4bd2W8nbeX/kykzBzn1cTUKoRWs2bwIYg1J8woIUNxLpa8bIIHlTzMwafcVMOV4mCdxeW9NoZ+jumS0jX5XTbL4v8dbmONwORUkTsTAvmie+iiwE6oIVu2fZRVm9BrWdSG4p/eqrc6leAo/07/kWbNURAEBKC4rfnceMj2SZtArZHSRIY7mQwWf9YmqGSPE9Ih38advJdWzppd/lhHVjNevIucZoGIw6i4SsoN6CsOT8szBcSJ/3A6NnNzaMMNRROfUfxRoev/1rS3ebzAbawIK3PxqR6/Wi5CAaaqRzxY1Vs19f1AgDzZg2ZE42GVT/wxFTxoI/zI5k5MWCFU5C7xC8El541O6IfG2bS4ESl9uhB0Pz8XzMAU9VQW6Us0Z+G4c+sjq0XwR0oIfS5aofufnqjErI2hlrdlqxqVbIL4oU0ZhOcQZY5lgoy1P826/s1LYsNRJGQ9dxVrvl8qey6XWk1sY0LPbhzBQ5UNXOpNR0FTb7CI6yO9RZLT/3D+Tag4fB8sf14apPAT9gw6+x662L+nd2ANRBV6jVKALOsaXcrMojnHufbvlLfFa2onFG9ueuoJSUESIMTYNrXRJuA3GJ2E2SIPS+4Ia6IHhmf1PP7X1HxVbmUbNvE4cMZISM0OkFLVF5jen2LoaWv1AkjLURjcX6sxsnKywYHFxokXXmEtbe6xs3j5ugFBgstP1xzdJmeutX0+wAAAAAAAAAAAAAAAAAAAAAAAAAAABEdLTs="
  }
]
use sha2::{Sha256, Sha512, Digest};
use blake3::Hasher as Blake3Hasher;
use hmac::{Hmac, Mac};
use crate::usecases::error::UseCaseError;
use hex;

pub fn sha256(data: &[u8]) -> String {
    let mut hasher = Sha256::new();
    hasher.update(data);
    let result = hasher.finalize();
    hex::encode(result)
}
pub fn sha512(data: &[u8]) -> String {
    let mut hasher = Sha512::new();
    hasher.update(data);
    format!("{:x}", hasher.finalize())
}
pub fn blake3(data: &[u8]) -> String {
    let mut hasher = Blake3Hasher::new();
    hasher.update(data);
    hasher.finalize().to_hex().to_string()
}
pub fn hmac_sha256(key: &[u8], data: &[u8]) -> Result<String, UseCaseError> {
    type HmacSha256 = Hmac<Sha256>;
    
    let mut mac = HmacSha256::new_from_slice(key)
        .map_err(|e| UseCaseError::Crypto(format!("Erro ao criar HMAC: {}", e)))?;
        
    mac.update(data);
    let result = mac.finalize();
    Ok(format!("{:x}", result.into_bytes()))
}
pub fn derive_key_pbkdf2(password: &[u8], salt: &[u8], iterations: u32, key_length: usize) -> Result<Vec<u8>, UseCaseError> {
    use pbkdf2::pbkdf2_hmac;
    
    let mut derived_key = vec![0u8; key_length];
    pbkdf2_hmac::<Sha256>(password, salt, iterations, &mut derived_key);
    
    Ok(derived_key)
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_sha256() {
        let data = b"teste de hash";
        let hash = sha256(data);
        assert_eq!(hash, "b5b3adc1c681faa2e743fd8250bd890c97bc0e48b07b7421c6180355f6776675");
    }
    
    #[test]
    fn test_sha512() {
        let data = b"teste de hash";
        let hash = sha512(data);
        assert_eq!(hash.len(), 128);
    }
    
    #[test]
    fn test_blake3() {
        let data = b"teste de hash";
        let hash = blake3(data);
        assert_eq!(hash.len(), 64);
    }
    
    #[test]
    fn test_hmac_sha256() {
        let key = b"chave secreta";
        let data = b"dados para autenticar";
        let hmac = hmac_sha256(key, data).unwrap();
        assert_eq!(hmac.len(), 64);
    }
    
    #[test]
    fn test_derive_key_pbkdf2() {
        let password = b"senha forte";
        let salt = b"salt aleatorio";
        let iterations = 10000;
        let key_length = 32;
        let derived_key = derive_key_pbkdf2(password, salt, iterations, key_length).unwrap();
        assert_eq!(derived_key.len(), key_length);
        
        let derived_key2 = derive_key_pbkdf2(password, salt, iterations, key_length).unwrap();
        assert_eq!(derived_key, derived_key2);
        
        let different_password = b"senha diferente";
        let derived_key3 = derive_key_pbkdf2(different_password, salt, iterations, key_length).unwrap();
        assert_ne!(derived_key, derived_key3);
    }
}pub mod pqc;
pub mod hash; // Add to Cargo.toml: pqcrypto-dilithium = "0.7"
use crate::usecases::error::UseCaseError;
use std::sync::Arc;
use pqcrypto_dilithium::dilithium2;
use pqcrypto::traits::sign::{PublicKey, SecretKey, DetachedSignature as DetachedSignatureTrait};
use sha2::{Sha256, Digest};
use base64::{Engine as _, engine::general_purpose};

/// Provedor de criptografia pós-quântica
pub struct PQCProvider {
    public_key: Option<Arc<dilithium2::PublicKey>>,
    secret_key: Option<Arc<dilithium2::SecretKey>>,
}

impl PQCProvider {
    /// Cria um novo provedor sem chaves
    pub fn new() -> Self {
        Self {
            public_key: None,
            secret_key: None,
        }
    }
    
    /// Gera um novo par de chaves
    pub fn generate_keypair(&mut self) -> Result<(String, String), UseCaseError> {
        let (pk, sk) = dilithium2::keypair();
        
        let pk_bytes = pk.as_bytes();
        let sk_bytes = sk.as_bytes();
        
        let pk_b64 = general_purpose::STANDARD.encode(pk_bytes);
        let sk_b64 = general_purpose::STANDARD.encode(sk_bytes);
        
        self.public_key = Some(Arc::new(pk));
        self.secret_key = Some(Arc::new(sk));
        
        Ok((pk_b64, sk_b64))
    }
    
    /// Carrega chaves existentes a partir de strings em base64
    pub fn load_keys(&mut self, public_key_b64: &str, secret_key_b64: Option<&str>) -> Result<(), UseCaseError> {
        let pk_bytes = general_purpose::STANDARD.decode(public_key_b64)
            .map_err(|e| UseCaseError::Crypto(format!("Falha ao decodificar chave pública: {}", e)))?;
            
        let pk = dilithium2::PublicKey::from_bytes(&pk_bytes)
            .map_err(|e| UseCaseError::Crypto(format!("Chave pública inválida: {}", e)))?;
            
        self.public_key = Some(Arc::new(pk));
        
        if let Some(sk_b64) = secret_key_b64 {
            let sk_bytes = general_purpose::STANDARD.decode(sk_b64)
                .map_err(|e| UseCaseError::Crypto(format!("Falha ao decodificar chave privada: {}", e)))?;
                
            let sk = dilithium2::SecretKey::from_bytes(&sk_bytes)
                .map_err(|e| UseCaseError::Crypto(format!("Chave privada inválida: {}", e)))?;
                
            self.secret_key = Some(Arc::new(sk));
        }
        
        Ok(())
    }
    
    /// Assina dados usando a chave privada
    pub fn sign(&self, data: &[u8]) -> Result<String, UseCaseError> {
        let sk = self.secret_key.as_ref().ok_or_else(|| {
            UseCaseError::Crypto("Chave privada não disponível".to_string())
        })?;
        
        // Calcula o hash SHA-256 dos dados primeiro (melhora o desempenho para dados grandes)
        let mut hasher = Sha256::new();
        hasher.update(data);
        let hash_result = hasher.finalize();
        
        // Assina o hash
        let signature = dilithium2::detached_sign(hash_result.as_slice(), sk);
        let sig_bytes = signature.as_bytes();
        
        // Retorna a assinatura em base64
        Ok(general_purpose::STANDARD.encode(sig_bytes))
    }
    
    /// Verifica uma assinatura
    pub fn verify(&self, data: &[u8], signature_b64: &str) -> Result<bool, UseCaseError> {
        let pk = self.public_key.as_ref().ok_or_else(|| {
            UseCaseError::Crypto("Chave pública não disponível".to_string())
        })?;
        
        // Decodifica a assinatura de base64
        let sig_bytes = general_purpose::STANDARD.decode(signature_b64)
            .map_err(|e| UseCaseError::Crypto(format!("Assinatura inválida: {}", e)))?;
            
        let signature = dilithium2::DetachedSignature::from_bytes(&sig_bytes)
            .map_err(|e| UseCaseError::Crypto(format!("Formato de assinatura inválido: {}", e)))?;
            
        // Calcula o hash SHA-256 dos dados
        let mut hasher = Sha256::new();
        hasher.update(data);
        let hash_result = hasher.finalize();
        
        // Verifica a assinatura contra o hash
        match dilithium2::verify_detached_signature(&signature, hash_result.as_slice(), pk) {
            Ok(_) => Ok(true),
            Err(_) => Ok(false),
        }
    }
    
    /// Obtém o hash da chave pública em formato hex
    pub fn get_public_key_hash(&self) -> Result<String, UseCaseError> {
        let pk = self.public_key.as_ref().ok_or_else(|| {
            UseCaseError::Crypto("Chave pública não disponível".to_string())
        })?;
        
        let mut hasher = Sha256::new();
        hasher.update(pk.as_bytes());
        let hash_result = hasher.finalize();
        
        Ok(format!("{:x}", hash_result))
    }
}

/// Funções para criar closures de assinatura e verificação
pub fn create_sign_function(provider: Arc<PQCProvider>) -> impl Fn(&[u8]) -> Result<String, UseCaseError> + Send + Sync + 'static {
    move |data: &[u8]| provider.sign(data)
}

pub fn create_verify_function(provider: Arc<PQCProvider>) -> impl Fn(&[u8], &str) -> Result<bool, UseCaseError> + Send + Sync + 'static {
    move |data: &[u8], signature: &str| provider.verify(data, signature)
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_generate_keypair() {
        let mut provider = PQCProvider::new();
        let (pk, sk) = provider.generate_keypair().unwrap();
        
        assert!(!pk.is_empty());
        assert!(!sk.is_empty());
    }
    
    #[test]
    fn test_load_keys() {
        let mut provider = PQCProvider::new();
        let (pk, sk) = provider.generate_keypair().unwrap();
        
        // Limpa as chaves
        provider.public_key = None;
        provider.secret_key = None;
        
        // Carrega as chaves novamente
        provider.load_keys(&pk, Some(&sk)).unwrap();
        
        assert!(provider.public_key.is_some());
        assert!(provider.secret_key.is_some());
    }
    
    #[test]
    fn test_sign_verify() {
        let mut provider = PQCProvider::new();
        provider.generate_keypair().unwrap();
        
        let data = b"Teste de assinatura e verificacao";
        
        // Assina os dados
        let signature = provider.sign(data).unwrap();
        
        // Verifica a assinatura
        let is_valid = provider.verify(data, &signature).unwrap();
        assert!(is_valid);
        
        // Verifica com dados diferentes (deve falhar)
        let different_data = b"Dados diferentes";
        let is_invalid = provider.verify(different_data, &signature).unwrap();
        assert!(!is_invalid);
    }
    
    #[test]
    fn test_get_public_key_hash() {
        let mut provider = PQCProvider::new();
        provider.generate_keypair().unwrap();
        
        let hash = provider.get_public_key_hash().unwrap();
        assert!(!hash.is_empty());
        assert_eq!(hash.len(), 64); // SHA-256 em hex tem 64 caracteres
    }
    
    #[test]
    fn test_sign_function_closure() {
        let mut provider = PQCProvider::new();
        provider.generate_keypair().unwrap();
        
        let provider_arc = Arc::new(provider);
        let sign_fn = create_sign_function(provider_arc.clone());
        
        let data = b"Teste da closure de assinatura";
        let signature = sign_fn(data).unwrap();
        
        assert!(!signature.is_empty());
    }
    
    #[test]
    fn test_verify_function_closure() {
        let mut provider = PQCProvider::new();
        provider.generate_keypair().unwrap();
        
        let data = b"Teste das closures";
        let signature = provider.sign(data).unwrap();
        
        let provider_arc = Arc::new(provider);
        let verify_fn = create_verify_function(provider_arc);
        
        let is_valid = verify_fn(data, &signature).unwrap();
        assert!(is_valid);
    }
} use crate::usecases::error::UseCaseError;
use reqwest::{Client, Response};
use std::time::Duration;

pub struct HttpClient {
    client: Client,
}

impl HttpClient {
    pub fn new() -> Result<Self, UseCaseError> {
        let client = Client::builder()
            .timeout(Duration::from_secs(30))
            .build()
            .map_err(|e| UseCaseError::Network(format!("Failed to create HTTP client: {}", e)))?;
            
        Ok(Self { client })
    }
    
    pub async fn get(&self, url: &str) -> Result<String, UseCaseError> {
        let response = self.client.get(url)
            .send()
            .await
            .map_err(|e| UseCaseError::Network(format!("HTTP GET request failed: {}", e)))?;
            
        self.process_response(response).await
    }
    
    pub async fn post(&self, url: &str, body: &str) -> Result<String, UseCaseError> {
        let response = self.client.post(url)
            .header("Content-Type", "application/json")
            .body(body.to_string())
            .send()
            .await
            .map_err(|e| UseCaseError::Network(format!("HTTP POST request failed: {}", e)))?;
            
        self.process_response(response).await
    }
    
    async fn process_response(&self, response: Response) -> Result<String, UseCaseError> {
        if !response.status().is_success() {
            return Err(UseCaseError::Network(format!(
                "HTTP request failed with status: {}", 
                response.status()
            )));
        }
        
        response.text()
            .await
            .map_err(|e| UseCaseError::Network(format!("Failed to read response body: {}", e)))
    }
} pub mod p2p;
pub mod http; use crate::domain::identity::DID;
use crate::domain::messaging::Message;
use crate::usecases::error::UseCaseError;
use crate::usecases::messaging::MessageSender;
use libp2p::{PeerId, Swarm};
use libp2p::gossipsub::{Behaviour as Gossipsub, Event as GossipsubEvent, IdentTopic, MessageAuthenticity, ValidationMode, MessageId, ConfigBuilder as GossipsubConfigBuilder};
use libp2p::kad::{Behaviour as Kademlia, Event as KademliaEvent, store::MemoryStore};
use libp2p::identify::{Behaviour as Identify, Event as IdentifyEvent};
use libp2p::ping::{Behaviour as Ping, Event as PingEvent};
use libp2p::mdns::{tokio::Behaviour as Mdns, Event as MdnsEvent, Config as MdnsConfig};
use libp2p::swarm::{SwarmEvent, NetworkBehaviour};
use std::collections::{HashMap, HashSet};
use std::sync::Arc;
use tokio::sync::{mpsc, RwLock, Mutex};
use futures_util::StreamExt;
use serde::{Serialize, Deserialize};
use std::str::FromStr;
use libp2p::gossipsub;
use libp2p::kad;
use libp2p::identify;
use libp2p::ping;
use libp2p::tcp::Config as TcpConfig;
use libp2p::noise::Config as NoiseConfig;
use libp2p::yamux::Config as YamuxConfig;
use libp2p::core::upgrade;
use libp2p::tcp::tokio::Transport as TokioTcpTransport;
use libp2p::Transport;
use std::pin::Pin;
use std::future::Future;
use std::time::Duration;
use std::num::NonZeroUsize;
// Make important types and traits public
// pub use self::NetworkMessageType;
// pub use self::NetworkMessage;
// pub use self::NetworkMessageHandler;

/// Mensagem de rede
/// 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NetworkMessage {
    pub message_type: NetworkMessageType,
    pub source_did: Option<String>,
    pub target_did: Option<String>,
    pub payload: Vec<u8>,
    pub topic: Option<String>,
}

/// Tipos de mensagens de rede
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub enum NetworkMessageType {
    /// Mensagem atous direta
    AtousMessage,
    /// Mensagem de sincronização da blockchain
    BlockchainSync,
    /// Mensagem de descoberta
    Discovery,
    /// Informação de peer (para bootstrap)
    PeerInfo,
    /// Heartbeat para verificar conectividade
    Heartbeat,
    /// Outros tipos de mensagens
    Custom(String),
}

/// Base trait for network message handlers
pub trait NetworkMessageHandler: Send + Sync {
    /// Handle a message synchronously, returning a future
    fn handle_message<'a>(&'a self, message: NetworkMessage) -> Pin<Box<dyn Future<Output = Result<Option<NetworkMessage>, UseCaseError>> + Send + 'a>>;
}

/// Comportamento da rede P2P
#[derive(NetworkBehaviour)]
#[behaviour(out_event = "P2PEvent")]
pub struct P2PBehaviour {
    gossipsub: Gossipsub,
    kad: Kademlia<MemoryStore>,
    identify: Identify,
    ping: Ping,
    mdns: Mdns,
}

impl P2PBehaviour {
    // ...existing code...

    // ...existing code...
}

/// Eventos da rede P2P
#[derive(Debug)]
pub enum P2PEvent {
    Gossipsub(GossipsubEvent),
    Kademlia(KademliaEvent),
    Identify(IdentifyEvent),
    Ping(PingEvent),
    Mdns(MdnsEvent),
}

impl From<GossipsubEvent> for P2PEvent {
    fn from(event: GossipsubEvent) -> Self {
        P2PEvent::Gossipsub(event)
    }
}

impl From<KademliaEvent> for P2PEvent {
    fn from(event: KademliaEvent) -> Self {
        P2PEvent::Kademlia(event)
    }
}

impl From<IdentifyEvent> for P2PEvent {
    fn from(event: IdentifyEvent) -> Self {
        P2PEvent::Identify(event)
    }
}

impl From<PingEvent> for P2PEvent {
    fn from(event: PingEvent) -> Self {
        P2PEvent::Ping(event)
    }
}

impl From<MdnsEvent> for P2PEvent {
    fn from(event: MdnsEvent) -> Self {
        P2PEvent::Mdns(event)
    }
}

/// Rede P2P baseada em libp2p
pub struct P2PNetwork {
    swarm: Arc<Mutex<Swarm<P2PBehaviour>>>,
    local_peer_id: PeerId,
    local_did: Option<DID>,
    subscribed_topics: Arc<RwLock<HashSet<String>>>,
    peer_dids: Arc<RwLock<HashMap<PeerId, String>>>,
    message_handlers: Arc<RwLock<Vec<Box<dyn NetworkMessageHandler>>>>,
    event_sender: mpsc::Sender<P2PEvent>,
    #[allow(dead_code)]  // This field is part of the design for future use
    event_receiver: Arc<Mutex<mpsc::Receiver<P2PEvent>>>,
    is_bootstrap: bool,
}

impl P2PNetwork {

    pub async fn new(
        _node_name: &str,
        bootstrap_peers: Vec<String>,
        is_bootstrap: bool,
    ) -> Result<Self, UseCaseError> {

        let id_keys = libp2p::identity::Keypair::generate_ed25519();
        let local_peer_id = PeerId::from(id_keys.public());
        
        log::info!("Local peer ID: {}", local_peer_id);

        // Configurar o transporte TCP
        let transport = TokioTcpTransport::new(TcpConfig::default().nodelay(true))
            .upgrade(upgrade::Version::V1)
            .authenticate(NoiseConfig::new(&id_keys).map_err(|e| UseCaseError::Network(format!("Falha ao criar configuração Noise: {}", e)))?)
            .multiplex(YamuxConfig::default())
            .boxed();

        let gossipsub_config = GossipsubConfigBuilder::default()
            .heartbeat_interval(std::time::Duration::from_secs(10))
            .validation_mode(ValidationMode::Strict)
            .message_id_fn(|message: &gossipsub::Message| {
                MessageId::from(&blake3::hash(&message.data).as_bytes()[..20])
            })
            .build()
            .map_err(|e| UseCaseError::Network(format!("Falha ao configurar Gossipsub: {}", e)))?;
            
        let mut gossipsub = Gossipsub::new(
            MessageAuthenticity::Signed(id_keys.clone()),
            gossipsub_config,
        )
        .map_err(|e| UseCaseError::Network(format!("Falha ao criar Gossipsub: {}", e)))?;
        

        let topic = IdentTopic::new("atous");
        gossipsub.subscribe(&topic)
            .map_err(|e| UseCaseError::Network(format!("Falha ao inscrever-se no tópico: {}", e)))?;
            
        let store = kad::store::MemoryStore::new(local_peer_id);
        let mut kad_config = kad::Config::default();
        
        if is_bootstrap {
            kad_config.set_replication_factor(NonZeroUsize::new(2).unwrap());
            kad_config.set_query_timeout(Duration::from_secs(60));
        }
        
        let mut kademlia = Kademlia::with_config(local_peer_id, store, kad_config);
        
        if !is_bootstrap {
            // Regular node - add bootstrap peers
            for peer_addr in bootstrap_peers {
                if let Ok((peer_id, addr)) = Self::parse_peer_addr(&peer_addr) {
                    log::info!("Adicionando bootstrap peer: {} at {}", peer_id, addr);
                    kademlia.add_address(&peer_id, addr);
                }
            }
        }

        let identify = Identify::new(identify::Config::new(
            "/atous/1.0.0".to_string(),
            id_keys.public(),
        ));
        
        let ping = Ping::new(ping::Config::new().with_interval(std::time::Duration::from_secs(30)));
        
        let mdns = Mdns::new(MdnsConfig::default(), local_peer_id)
            .map_err(|e| UseCaseError::Network(format!("Falha ao inicializar mDNS: {}", e)))?;
            
        let behaviour = P2PBehaviour {
            gossipsub,
            kad: kademlia,
            identify,
            ping,
            mdns,
        };
        
        let swarm = Swarm::new(transport, behaviour, local_peer_id, libp2p::swarm::Config::with_tokio_executor());
        
        let (tx, rx) = mpsc::channel(100);
        
        let network = Self {
            swarm: Arc::new(Mutex::new(swarm)),
            local_peer_id,
            local_did: None,
            subscribed_topics: Arc::new(RwLock::new(HashSet::new())),
            peer_dids: Arc::new(RwLock::new(HashMap::new())),
            message_handlers: Arc::new(RwLock::new(Vec::new())),
            event_sender: tx,
            event_receiver: Arc::new(Mutex::new(rx)),
            is_bootstrap,
        };
        
        let mut topics = network.subscribed_topics.write().await;
        topics.insert("atous".to_string());
        drop(topics);
        
        Ok(network)
    }
    
    pub async fn start(&self, listen_addr: &str) -> Result<(), UseCaseError> {
        let mut swarm = self.swarm.lock().await;
        
        let addr = listen_addr
            .parse()
            .map_err(|e| UseCaseError::Network(format!("Endereço inválido: {}", e)))?;
            
        swarm.listen_on(addr)
            .map_err(|e| UseCaseError::Network(format!("Falha ao iniciar listener: {}", e)))?;
            
        let event_sender = self.event_sender.clone();
        let swarm_clone = self.swarm.clone();
        let message_handlers = self.message_handlers.clone();
        let peer_dids = self.peer_dids.clone();
        
        tokio::spawn(async move {
            let mut swarm = swarm_clone.lock().await;
            
            loop {
                match swarm.select_next_some().await {
                    SwarmEvent::NewListenAddr { address, .. } => {
                        log::info!("Listening on {}", address);
                    }
                    SwarmEvent::Behaviour(event) => {
                        Self::handle_p2p_event(
                            event,
                            &mut swarm,
                            &message_handlers,
                            &peer_dids,
                            &event_sender,
                        ).await;
                    }
                    _ => {}
                }
            }
        });
        
        // Only perform DHT bootstrap for non-bootstrap nodes
        if !self.is_bootstrap {
            // Give the bootstrap node time to initialize
            tokio::time::sleep(Duration::from_secs(1)).await;
            
            match swarm.behaviour_mut().kad.bootstrap() {
                Ok(_) => {
                    log::info!("Started Kademlia bootstrap process");
                }
                Err(e) => {
                    // Just log the error but don't fail - the node might still work through mDNS
                    log::warn!("Failed to start Kademlia bootstrap: {}", e);
                }
            }
        } else {
            log::info!("Running as bootstrap node - skipping bootstrap process");
        }
            
        log::info!("Rede P2P inicializada com sucesso");
        
        Ok(())
    }
    
    /// Processa eventos da rede P2P
    async fn handle_p2p_event(
        event: P2PEvent,
        swarm: &mut Swarm<P2PBehaviour>,
        message_handlers: &Arc<RwLock<Vec<Box<dyn NetworkMessageHandler>>>>,
        peer_dids: &Arc<RwLock<HashMap<PeerId, String>>>,
        event_sender: &mpsc::Sender<P2PEvent>,
    ) {
        match event {
            P2PEvent::Gossipsub(GossipsubEvent::Message {
                propagation_source,
                message_id: _,
                ref message,
            }) => {
                log::debug!(
                    "Recebida mensagem Gossipsub de {} no tópico {:?}",
                    propagation_source,
                    message.topic
                );
                
                // Tenta deserializar a mensagem
                if let Ok(network_message) = serde_json::from_slice::<NetworkMessage>(&message.data) {
                    // Se tiver um DID de origem, registra o mapeamento peer_id -> DID
                    if let Some(source_did) = &network_message.source_did {
                        let mut dids = peer_dids.write().await;
                        dids.insert(propagation_source, source_did.clone());
                    }
                    
                    // Processa a mensagem com os handlers
                    let handlers = message_handlers.read().await;
                    for handler in handlers.iter() {
                        if let Ok(Some(response)) = handler.handle_message(network_message.clone()).await {
                            // Se houver resposta, envie de volta
                            if let Ok(response_data) = serde_json::to_vec(&response) {
                                if let Some(topic_str) = &network_message.topic {
                                    let topic = IdentTopic::new(topic_str);
                                    if let Err(e) = swarm.behaviour_mut().gossipsub.publish(topic, response_data) {
                                        log::error!("Falha ao publicar resposta: {}", e);
                                    }
                                }
                            }
                        }
                    }
                } else {
                    log::warn!("Recebida mensagem Gossipsub que não pôde ser deserializada");
                }
            }
            
            P2PEvent::Mdns(MdnsEvent::Discovered(ref peers)) => {
                for (peer_id, addr) in peers {
                    log::debug!("mDNS descobriu peer: {} em {}", peer_id, addr);
                    swarm.behaviour_mut().kad.add_address(&peer_id, addr.clone());
                }
            }
            
            P2PEvent::Identify(IdentifyEvent::Received {
                peer_id, ref info, ..
            }) => {
                log::debug!("Recebidas informações identify de {}: {:?}", peer_id, info);
                // Adiciona endereços conhecidos do peer ao Kademlia
                for addr in info.listen_addrs.iter() {
                    swarm.behaviour_mut().kad.add_address(&peer_id, addr.clone());
                }
            }
            
            P2PEvent::Kademlia(KademliaEvent::OutboundQueryProgressed {
                ref result, ..
            }) => {
                match result {
                    kad::QueryResult::Bootstrap(Ok(_)) => {
                        log::info!("Bootstrap Kademlia completo");
                    }
                    kad::QueryResult::GetClosestPeers(Ok(peers)) => {
                        log::debug!("Peers mais próximos: {:?}", peers);
                    }
                    _ => {}
                }
            }
            
            _ => {}
        }
        
        // Encaminha o evento para o canal
        if let Err(e) = event_sender.try_send(event) {
            if matches!(e, tokio::sync::mpsc::error::TrySendError::Full(_)) {
                log::warn!("Canal de eventos cheio, descartando evento");
            }
        }
    }
    
    /// Parseia um endereço de peer no formato PeerId:multiaddr
    fn parse_peer_addr(addr: &str) -> Result<(PeerId, libp2p::Multiaddr), UseCaseError> {
        let parts: Vec<&str> = addr.split(':').collect();
        
        if parts.len() < 2 {
            return Err(UseCaseError::Network(format!("Formato de endereço inválido: {}", addr)));
        }
        
        let peer_id_str = parts[0];
        let peer_id = PeerId::from_str(peer_id_str)
            .map_err(|e| UseCaseError::Network(format!("PeerId inválido: {}", e)))?;
            
        let addr_str = parts[1..].join(":");
        let addr = addr_str.parse()
            .map_err(|e| UseCaseError::Network(format!("Multiaddr inválido: {}", e)))?;
            
        Ok((peer_id, addr))
    }
    
    /// Registra um DID local com a rede
    pub async fn set_local_did(&mut self, did: DID) {
        self.local_did = Some(did);
    }
    
    /// Adiciona um handler de mensagens
    pub async fn add_message_handler(&self, handler: Box<dyn NetworkMessageHandler>) {
        let mut handlers = self.message_handlers.write().await;
        handlers.push(handler);
    }

    pub async fn get_message_handlers(&self) -> tokio::sync::RwLockReadGuard<'_, Vec<Box<dyn NetworkMessageHandler>>> {
        self.message_handlers.read().await
    }
    
    pub async fn subscribe_to_topic(&self, topic_name: &str) -> Result<(), UseCaseError> {
        let topic = IdentTopic::new(topic_name);
        
        let mut topics = self.subscribed_topics.write().await;
        
        if !topics.contains(topic_name) {
            let mut swarm = self.swarm.lock().await;
            swarm.behaviour_mut().gossipsub.subscribe(&topic)
                .map_err(|e| UseCaseError::Network(format!("Falha ao inscrever-se no tópico: {}", e)))?;
                
            topics.insert(topic_name.to_string());
        }
        
        Ok(())
    }
    
    /// Envia uma mensagem para um tópico específico
    pub async fn publish_to_topic(&self, topic_name: &str, message: NetworkMessage) -> Result<(), UseCaseError> {
        let mut message = message;
        
        // Adiciona o DID de origem se não estiver definido
        if message.source_did.is_none() {
            if let Some(local_did) = &self.local_did {
                message.source_did = Some(local_did.to_string());
            }
        }
        
        // Define o tópico na mensagem
        message.topic = Some(topic_name.to_string());
        
        let data = serde_json::to_vec(&message)
            .map_err(|e| UseCaseError::Internal(format!("Falha ao serializar mensagem: {}", e)))?;
            
        let topic = IdentTopic::new(topic_name);
        
        // Verifica se estamos inscritos no tópico
        {
            let topics = self.subscribed_topics.read().await;
            if !topics.contains(topic_name) {
                self.subscribe_to_topic(topic_name).await?;
            }
        }
        
        // Publica a mensagem
        let mut swarm = self.swarm.lock().await;
        swarm.behaviour_mut().gossipsub.publish(topic, data)
            .map_err(|e| UseCaseError::Network(format!("Falha ao publicar mensagem: {}", e)))?;
            
        Ok(())
    }
    
    /// Envia uma mensagem direta para um peer específico (identificado pelo DID)
    pub async fn send_direct_message(&self, target_did: &str, message: NetworkMessage) -> Result<(), UseCaseError> {
        let mut message = message;
        
        // Adiciona DID de origem e destino
        if message.source_did.is_none() {
            if let Some(local_did) = &self.local_did {
                message.source_did = Some(local_did.to_string());
            }
        }
        
        message.target_did = Some(target_did.to_string());
        
        // Usa o tópico para mensagens diretas
        let topic_name = format!("atous/direct/{}", target_did);
        message.topic = Some(topic_name.clone());
        
        // Publica no tópico correspondente ao DID de destino
        self.publish_to_topic(&topic_name, message).await
    }
    
    /// Busca peers pelo DID
    pub async fn lookup_peer_by_did(&self, did: &str) -> Option<PeerId> {
        let dids = self.peer_dids.read().await;
        
        for (peer_id, peer_did) in dids.iter() {
            if peer_did == did {
                return Some(*peer_id);
            }
        }
        
        None
    }
    
    /// Busca o DID de um peer
    pub async fn lookup_did_by_peer(&self, peer_id: &PeerId) -> Option<String> {
        let dids = self.peer_dids.read().await;
        dids.get(peer_id).cloned()
    }
    
    /// Retorna o PeerId local
    pub fn local_peer_id(&self) -> PeerId {
        self.local_peer_id
    }
    
    /// Retorna o DID local
    pub fn local_did(&self) -> Option<DID> {
        self.local_did.clone()
    }

    /// Desliga a rede P2P de forma limpa
    pub async fn shutdown(&self) -> Result<(), UseCaseError> {
        // Limpa os handlers de mensagens
        {
            let mut handlers = self.message_handlers.write().await;
            handlers.clear();
        }

        // Limpa os tópicos inscritos
        {
            let mut topics = self.subscribed_topics.write().await;
            topics.clear();
        }

        // Limpa os DIDs dos peers
        {
            let mut dids = self.peer_dids.write().await;
            dids.clear();
        }

        Ok(())
    }

    /// Get number of connected peers - used for testing
    pub async fn connected_peer_count(&self) -> usize {
        let swarm = self.swarm.lock().await;
        swarm.connected_peers().count()
    }
}

/// Handler de mensagem padrão que converte NetworkMessage para Message do domínio
pub struct MessageBridgeHandler {
    message_service: Arc<dyn MessageSender>,
}

impl MessageBridgeHandler {
    pub fn new(message_service: Arc<dyn MessageSender>) -> Self {
        Self { message_service }
    }
}

impl NetworkMessageHandler for MessageBridgeHandler {
    fn handle_message<'a>(&'a self, network_message: NetworkMessage) -> Pin<Box<dyn Future<Output = Result<Option<NetworkMessage>, UseCaseError>> + Send + 'a>> {
        Box::pin(async move {
            if network_message.message_type != NetworkMessageType::AtousMessage {
                return Ok(None);
            }
            
            let domain_message: Message = serde_json::from_slice(&network_message.payload)
                .map_err(|e| UseCaseError::Internal(format!("Falha ao deserializar mensagem: {}", e)))?;
                
            let _message_id = self.message_service.send_message(domain_message).await?;
            
            Ok(None)
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::str::FromStr;
    
    // Teste de criação da rede
    #[tokio::test]
    async fn test_create_p2p_network() {
        let network = P2PNetwork::new(
            "test_node",
            vec![],
            false,
        ).await;
        
        assert!(network.is_ok());
    }
    
    // Teste de serialização/deserialização de mensagens
    #[test]
    fn test_network_message_serialization() {
        let message = NetworkMessage {
            message_type: NetworkMessageType::AtousMessage,
            source_did: Some("did:atous:123".to_string()),
            target_did: Some("did:atous:456".to_string()),
            payload: vec![1, 2, 3, 4],
            topic: Some("test".to_string()),
        };
        
        let serialized = serde_json::to_string(&message).unwrap();
        let deserialized: NetworkMessage = serde_json::from_str(&serialized).unwrap();
        
        assert_eq!(deserialized.message_type, NetworkMessageType::AtousMessage);
        assert_eq!(deserialized.source_did, Some("did:atous:123".to_string()));
        assert_eq!(deserialized.target_did, Some("did:atous:456".to_string()));
        assert_eq!(deserialized.payload, vec![1, 2, 3, 4]);
        assert_eq!(deserialized.topic, Some("test".to_string()));
    }
    
    // Teste de parse de endereço de peer
    #[test]
    fn test_parse_peer_addr() {
        let addr_str = "12D3KooWD3XbkQizgJLbJbGQmayaDYgKPwXEWQQE7XSnQjVzT5Ed:/ip4/127.0.0.1/tcp/4001";
        
        let result = P2PNetwork::parse_peer_addr(addr_str);
        assert!(result.is_ok());
        
        let (peer_id, addr) = result.unwrap();
        assert_eq!(
            peer_id,
            PeerId::from_str("12D3KooWD3XbkQizgJLbJbGQmayaDYgKPwXEWQQE7XSnQjVzT5Ed").unwrap()
        );
        assert_eq!(addr.to_string(), "/ip4/127.0.0.1/tcp/4001");
    }

    use tokio::time::sleep;
    use std::time::Duration;

    #[tokio::test]
    async fn test_multiple_node_network() {
        // 1. Initialize bootstrap node
        let bootstrap_node = P2PNetwork::new(
            "bootstrap_node",
            vec![], // No bootstrap peers needed for bootstrap node
            true,  // is_bootstrap = true
        ).await.expect("Failed to create bootstrap node");
        
        // Start bootstrap node on a specific port
        bootstrap_node.start("/ip4/127.0.0.1/tcp/45000").await
            .expect("Failed to start bootstrap node");
            
        // Give bootstrap node time to start
        sleep(Duration::from_secs(2)).await;

        // Get bootstrap node's address for other nodes to connect
        let bootstrap_addr = format!("{}:/ip4/127.0.0.1/tcp/45000", 
            bootstrap_node.local_peer_id());

        // 2. Create regular nodes that connect to bootstrap node
        let regular_nodes = vec![
            ("node1", 45001),
            ("node2", 45002),
        ];

        let mut nodes = Vec::new();

        for (name, port) in regular_nodes {
            let node = P2PNetwork::new(
                name,
                vec![bootstrap_addr.clone()],
                false, // not a bootstrap node
            ).await.expect(&format!("Failed to create node {}", name));

            node.start(&format!("/ip4/127.0.0.1/tcp/{}", port)).await
                .expect(&format!("Failed to start node {}", name));

            nodes.push(node);
        }

        // Give nodes time to discover each other through DHT
        sleep(Duration::from_secs(5)).await;

        // Verify that nodes have discovered each other
        let bootstrap_peers = bootstrap_node.connected_peer_count().await;
        assert!(bootstrap_peers > 0, "Bootstrap node should have connected peers");

        for (i, node) in nodes.iter().enumerate() {
            let peer_count = node.connected_peer_count().await;
            assert!(peer_count > 0, "Node {} should have connected peers", i + 1);
        }

        // Clean up
        bootstrap_node.shutdown().await.expect("Failed to shutdown bootstrap node");
        for node in nodes {
            node.shutdown().await.expect("Failed to shutdown node");
        }
    }
}#[cfg(test)]
mod tests {
    use super::*;
    use tokio::time::sleep;
    use std::time::Duration;

    #[tokio::test]
    async fn test_multiple_node_network() {
        // 1. Initialize bootstrap node
        let bootstrap_node = P2PNetwork::new(
            "bootstrap_node",
            vec![], // No bootstrap peers needed for bootstrap node
            true,  // is_bootstrap = true
        ).await.expect("Failed to create bootstrap node");
        
        // Start bootstrap node on a specific port
        bootstrap_node.start("/ip4/127.0.0.1/tcp/45000").await
            .expect("Failed to start bootstrap node");
            
        // Give bootstrap node time to start
        sleep(Duration::from_secs(2)).await;

        // Get bootstrap node's address for other nodes to connect
        let bootstrap_addr = format!("{}:/ip4/127.0.0.1/tcp/45000", 
            bootstrap_node.local_peer_id());

        // 2. Create regular nodes that connect to bootstrap node
        let regular_nodes = vec![
            ("node1", 45001),
            ("node2", 45002),
        ];

        let mut nodes = Vec::new();

        for (name, port) in regular_nodes {
            let node = P2PNetwork::new(
                name,
                vec![bootstrap_addr.clone()],
                false, // not a bootstrap node
            ).await.expect(&format!("Failed to create node {}", name));

            node.start(&format!("/ip4/127.0.0.1/tcp/{}", port)).await
                .expect(&format!("Failed to start node {}", name));

            nodes.push(node);
        }

        // Give nodes time to discover each other through DHT
        // We'll retry peer checks a few times to allow for discovery
        let mut success = false;
        for attempt in 1..=6 {
            sleep(Duration::from_secs(5)).await;
            
            let bootstrap_peers = bootstrap_node.connected_peer_count().await;
            let mut all_connected = true;
            let mut node_statuses = Vec::new();
            
            for (i, node) in nodes.iter().enumerate() {
                let peer_count = node.connected_peer_count().await;
                node_statuses.push((i + 1, peer_count));
                if peer_count == 0 {
                    all_connected = false;
                }
            }
            
            log::info!(
                "Attempt {}/6 - Bootstrap node has {} peers. Node statuses: {:?}",
                attempt, bootstrap_peers, node_statuses
            );
            
            if bootstrap_peers > 0 && all_connected {
                success = true;
                break;
            }
        }
        
        assert!(success, "Failed to establish connections between nodes after multiple attempts");

        for (i, node) in nodes.iter().enumerate() {
            let peer_count = node.connected_peer_count().await;
            assert!(peer_count > 0, "Node {} should have connected peers", i + 1);
        }

        // Clean up
        bootstrap_node.shutdown().await.expect("Failed to shutdown bootstrap node");
        for node in nodes {
            node.shutdown().await.expect("Failed to shutdown node");
        }
    }
}use std::fs;
use std::path::Path;
use crate::usecases::error::UseCaseError;

pub struct FilePersistenceAdapter {
    base_path: String,
}

impl FilePersistenceAdapter {
    
    pub fn new(base_path: &str) -> Self {
        if let Some(parent) = Path::new(base_path).parent() {
            fs::create_dir_all(parent).ok();
        }
        
        Self {
            base_path: base_path.to_string(),
        }
    }
    
    pub fn save(&self, key: &str, data: &str) -> Result<(), UseCaseError> {
        let path = format!("{}/{}", self.base_path, key);
        fs::write(&path, data)
            .map_err(|e| UseCaseError::Internal(format!("Failed to write file {}: {}", path, e)))?;
        Ok(())
    }
    
    pub fn load(&self, key: &str) -> Result<Option<String>, UseCaseError> {
        let path = format!("{}/{}", self.base_path, key);
        let file_path = Path::new(&path);
        
        if !file_path.exists() {
            return Ok(None);
        }
        
        let data = fs::read_to_string(file_path)
            .map_err(|e| UseCaseError::Internal(format!("Failed to read file {}: {}", path, e)))?;
            
        Ok(Some(data))
    }
    
    pub fn delete(&self, key: &str) -> Result<bool, UseCaseError> {
        let path = format!("{}/{}", self.base_path, key);
        let file_path = Path::new(&path);
        
        if !file_path.exists() {
            return Ok(false);
        }
        
        fs::remove_file(file_path)
            .map_err(|e| UseCaseError::Internal(format!("Failed to delete file {}: {}", path, e)))?;
            
        Ok(true)
    }
}

 pub mod redis;
pub mod file; use redis::{Client, Connection, FromRedisValue, ToRedisArgs};
use serde::{Serialize, Deserialize};
use std::future::Future;
use crate::usecases::error::UseCaseError;
use std::sync::Arc;
use tokio::sync::Mutex;
use std::collections::HashMap;

pub struct RedisClient {
    client: Client,
    connection_pool: Arc<Mutex<Vec<Connection>>>,
    #[allow(dead_code)]
    max_pool_size: usize,
}

impl RedisClient {
    pub fn new(redis_url: &str, pool_size: usize) -> Result<Self, UseCaseError> {
        let client = Client::open(redis_url)
            .map_err(UseCaseError::Database)?;
            
        let mut connection_pool = Vec::with_capacity(pool_size);
        
        // Inicializa o pool com conexões
        for _ in 0..pool_size {
            match client.get_connection() {
                Ok(conn) => connection_pool.push(conn),
                Err(e) => {
                    log::warn!("Falha ao criar conexão inicial: {}", e);
                    // Não falha, apenas reduz o tamanho do pool
                }
            }
        }
        
        Ok(Self {
            client,
            connection_pool: Arc::new(Mutex::new(connection_pool)),
            max_pool_size: pool_size,
        })
    }
    
    /// Obtém uma conexão do pool ou cria uma nova
    async fn get_connection(&self) -> Result<PooledConnection, UseCaseError> {
        let mut pool = self.connection_pool.lock().await;
        
        if let Some(conn) = pool.pop() {
            return Ok(PooledConnection { 
                conn: Some(conn), 
                pool: self.connection_pool.clone(),
            });
        }
        
        // Se não há conexões disponíveis, cria uma nova
        let conn = self.client.get_connection()
            .map_err(UseCaseError::Database)?;
            
        Ok(PooledConnection { 
            conn: Some(conn), 
            pool: self.connection_pool.clone(),
        })
    }
    
    /// Salva um valor chave-valor
    pub async fn set<K: ToRedisArgs, V: ToRedisArgs>(&self, key: K, value: V) -> Result<(), UseCaseError> {
        let mut conn = self.get_connection().await?;
        
        redis::cmd("SET")
            .arg(key)
            .arg(value)
            .query::<()>(&mut conn)
            .map_err(UseCaseError::Database)?;
            
        Ok(())
    }
    
    /// Salva um valor chave-valor com expiração (em segundos)
    pub async fn set_ex<K: ToRedisArgs, V: ToRedisArgs>(&self, key: K, value: V, ttl: usize) -> Result<(), UseCaseError> {
        let mut conn = self.get_connection().await?;
        
        redis::cmd("SETEX")
            .arg(key)
            .arg(ttl)
            .arg(value)
            .query::<()>(&mut conn)
            .map_err(UseCaseError::Database)?;
            
        Ok(())
    }
    
    /// Obtém um valor
    pub async fn get<K: ToRedisArgs, V: FromRedisValue>(&self, key: K) -> Result<Option<V>, UseCaseError> {
        let mut conn = self.get_connection().await?;
        
        let result: Option<V> = redis::cmd("GET")
            .arg(key)
            .query::<Option<V>>(&mut conn)
            .map_err(UseCaseError::Database)?;
            
        Ok(result)
    }
    
    /// Verifica se uma chave existe
    pub async fn exists<K: ToRedisArgs>(&self, key: K) -> Result<bool, UseCaseError> {
        let mut conn = self.get_connection().await?;
        
        let result: i32 = redis::cmd("EXISTS")
            .arg(key)
            .query::<i32>(&mut conn)
            .map_err(UseCaseError::Database)?;
            
        Ok(result == 1)
    }
    
    /// Exclui uma chave
    pub async fn delete<K: ToRedisArgs>(&self, key: K) -> Result<bool, UseCaseError> {
        let mut conn = self.get_connection().await?;
        
        let result: i32 = redis::cmd("DEL")
            .arg(key)
            .query::<i32>(&mut conn)
            .map_err(UseCaseError::Database)?;
            
        Ok(result > 0)
    }
    
    /// Adiciona um item a uma lista
    pub async fn list_push<K: ToRedisArgs, V: ToRedisArgs>(&self, key: K, value: V) -> Result<(), UseCaseError> {
        let mut conn = self.get_connection().await?;
        
        redis::cmd("RPUSH")
            .arg(key)
            .arg(value)
            .query::<()>(&mut conn)
            .map_err(UseCaseError::Database)?;
            
        Ok(())
    }
    
    /// Obtém uma lista
    pub async fn list_range<K: ToRedisArgs, V: FromRedisValue>(&self, key: K, start: isize, stop: isize) -> Result<Vec<V>, UseCaseError> {
        let mut conn = self.get_connection().await?;
        
        let result: Vec<V> = redis::cmd("LRANGE")
            .arg(key)
            .arg(start)
            .arg(stop)
            .query::<Vec<V>>(&mut conn)
            .map_err(UseCaseError::Database)?;
            
        Ok(result)
    }
    
    /// Adiciona um par chave-valor a um hash
    pub async fn hash_set<K: ToRedisArgs, F: ToRedisArgs, V: ToRedisArgs>(&self, key: K, field: F, value: V) -> Result<(), UseCaseError> {
        let mut conn = self.get_connection().await?;
        
        redis::cmd("HSET")
            .arg(key)
            .arg(field)
            .arg(value)
            .query::<()>(&mut conn)
            .map_err(UseCaseError::Database)?;
            
        Ok(())
    }
    
    /// Obtém um valor de um hash
    pub async fn hash_get<K: ToRedisArgs, F: ToRedisArgs, V: FromRedisValue>(&self, key: K, field: F) -> Result<Option<V>, UseCaseError> {
        let mut conn = self.get_connection().await?;
        
        let result: Option<V> = redis::cmd("HGET")
            .arg(key)
            .arg(field)
            .query::<Option<V>>(&mut conn)
            .map_err(UseCaseError::Database)?;
            
        Ok(result)
    }
    
    /// Obtém todos os pares chave-valor de um hash
    pub async fn hash_get_all<K: ToRedisArgs, V: FromRedisValue>(&self, key: K) -> Result<HashMap<String, V>, UseCaseError> {
        use std::collections::HashMap;
        
        let mut conn = self.get_connection().await?;
        
        let result: HashMap<String, V> = redis::cmd("HGETALL")
            .arg(key)
            .query::<HashMap<String, V>>(&mut conn)
            .map_err(UseCaseError::Database)?;
            
        Ok(result)
    }
    
    /// Adiciona um item a um conjunto
    pub async fn set_add<K: ToRedisArgs, V: ToRedisArgs>(&self, key: K, value: V) -> Result<bool, UseCaseError> {
        let mut conn = self.get_connection().await?;
        
        let result: i32 = redis::cmd("SADD")
            .arg(key)
            .arg(value)
            .query::<i32>(&mut conn)
            .map_err(UseCaseError::Database)?;
            
        Ok(result > 0) // Retorna true se o item foi adicionado
    }
    
    /// Obtém todos os itens de um conjunto
    pub async fn set_members<K: ToRedisArgs, V: FromRedisValue>(&self, key: K) -> Result<Vec<V>, UseCaseError> {
        let mut conn = self.get_connection().await?;
        
        let result: Vec<V> = redis::cmd("SMEMBERS")
            .arg(key)
            .query::<Vec<V>>(&mut conn)
            .map_err(UseCaseError::Database)?;
            
        Ok(result)
    }
    
    /// Verifica se um item está em um conjunto
    pub async fn set_is_member<K: ToRedisArgs, V: ToRedisArgs>(&self, key: K, value: V) -> Result<bool, UseCaseError> {
        let mut conn = self.get_connection().await?;
        
        let result: i32 = redis::cmd("SISMEMBER")
            .arg(key)
            .arg(value)
            .query::<i32>(&mut conn)
            .map_err(UseCaseError::Database)?;
            
        Ok(result == 1)
    }
    
    /// Publica uma mensagem em um canal
    pub async fn publish<C: ToRedisArgs, M: ToRedisArgs>(&self, channel: C, message: M) -> Result<i32, UseCaseError> {
        let mut conn = self.get_connection().await?;
        
        let result: i32 = redis::cmd("PUBLISH")
            .arg(channel)
            .arg(message)
            .query::<i32>(&mut conn)
            .map_err(UseCaseError::Database)?;
            
        Ok(result) // Número de clientes que receberam a mensagem
    }
}

/// Representa uma conexão Redis obtida do pool
pub struct PooledConnection {
    conn: Option<Connection>,
    pool: Arc<Mutex<Vec<Connection>>>,
}

impl std::ops::Deref for PooledConnection {
    type Target = Connection;
    
    fn deref(&self) -> &Self::Target {
        self.conn.as_ref().unwrap()
    }
}

impl std::ops::DerefMut for PooledConnection {
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.conn.as_mut().unwrap()
    }
}

impl Drop for PooledConnection {
    fn drop(&mut self) {
        // Quando a conexão for eliminada, devolve-a ao pool
        if let Some(conn) = self.conn.take() {
            let pool = self.pool.clone();
            
            tokio::spawn(async move {
                let mut pool_guard = pool.lock().await;
                pool_guard.push(conn);
            });
        }
    }
}

/// Trait para serializar/deserializar objetos no Redis
pub trait RedisSerializable: Serialize + for<'de> Deserialize<'de> + Sized {
    /// Chave para armazenamento no Redis
    fn redis_key(&self) -> String;
    
    /// Carrega o objeto do Redis
    #[allow(unused)]
    fn load_from_redis(key: &str, client: &RedisClient) -> impl Future<Output = Result<Option<Self>, UseCaseError>> + Send {
        let key = key.to_string(); // Clone the key to move into the async block
        async move {
            let data: Option<String> = client.get(key).await?;
            
            if let Some(serialized) = data {
                let object = serde_json::from_str(&serialized)
                    .map_err(|e| UseCaseError::Internal(format!("Erro ao deserializar: {}", e)))?;
                    
                Ok(Some(object))
            } else {
                Ok(None)
            }
        }
    }
            
    #[allow(unused)]
    fn save_to_redis(&self, client: &RedisClient) -> impl Future<Output = Result<(), UseCaseError>> + Send {
        let key = self.redis_key();
        let json = serde_json::to_string(self);
        async move {
            let json = json?;
            client.set(key, json).await
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::HashMap;
    
    // Estes testes exigem um servidor Redis em execução
    // Portanto, são ignorados por padrão
    
    #[tokio::test]
    #[ignore]
    async fn test_redis_key_value() {
        let client = RedisClient::new("redis://127.0.0.1/", 5).unwrap();
        
        // Testa operações básicas de chave-valor
        client.set("test_key", "test_value").await.unwrap();
        
        let value: Option<String> = client.get("test_key").await.unwrap();
        assert_eq!(value, Some("test_value".to_string()));
        
        let exists = client.exists("test_key").await.unwrap();
        assert!(exists);
        
        client.delete("test_key").await.unwrap();
        
        let value: Option<String> = client.get("test_key").await.unwrap();
        assert_eq!(value, None);
    }
    
    #[tokio::test]
    #[ignore]
    async fn test_redis_list() {
        let client = RedisClient::new("redis://127.0.0.1/", 5).unwrap();
        
        // Limpa testes anteriores
        client.delete("test_list").await.unwrap();
        
        // Testa operações de lista
        client.list_push("test_list", "item1").await.unwrap();
        client.list_push("test_list", "item2").await.unwrap();
        client.list_push("test_list", "item3").await.unwrap();
        
        let items: Vec<String> = client.list_range("test_list", 0, -1).await.unwrap();
        assert_eq!(items, vec!["item1", "item2", "item3"]);
        
        // Obtém uma sublista
        let items: Vec<String> = client.list_range("test_list", 0, 1).await.unwrap();
        assert_eq!(items, vec!["item1", "item2"]);
        
        client.delete("test_list").await.unwrap();
    }
    
    #[tokio::test]
    #[ignore]
    async fn test_redis_hash() {
        let client = RedisClient::new("redis://127.0.0.1/", 5).unwrap();
        
        // Limpa testes anteriores
        client.delete("test_hash").await.unwrap();
        
        // Testa operações de hash
        client.hash_set("test_hash", "field1", "value1").await.unwrap();
        client.hash_set("test_hash", "field2", "value2").await.unwrap();
        
        let value: Option<String> = client.hash_get("test_hash", "field1").await.unwrap();
        assert_eq!(value, Some("value1".to_string()));
        
        let all: HashMap<String, String> = client.hash_get_all("test_hash").await.unwrap();
        assert_eq!(all.len(), 2);
        assert_eq!(all.get("field1"), Some(&"value1".to_string()));
        assert_eq!(all.get("field2"), Some(&"value2".to_string()));
        
        client.delete("test_hash").await.unwrap();
    }
    
    #[tokio::test]
    #[ignore]
    async fn test_redis_set() {
        let client = RedisClient::new("redis://127.0.0.1/", 5).unwrap();
        
        // Limpa testes anteriores
        client.delete("test_set").await.unwrap();
        
        // Testa operações de conjunto
        client.set_add("test_set", "item1").await.unwrap();
        client.set_add("test_set", "item2").await.unwrap();
        client.set_add("test_set", "item1").await.unwrap(); // Duplicado, não deve ser adicionado
        
        let is_member = client.set_is_member("test_set", "item1").await.unwrap();
        assert!(is_member);
        
        let members: Vec<String> = client.set_members("test_set").await.unwrap();
        assert_eq!(members.len(), 2);
        assert!(members.contains(&"item1".to_string()));
        assert!(members.contains(&"item2".to_string()));
        
        client.delete("test_set").await.unwrap();
    }
    
    #[tokio::test]
    #[ignore]
    async fn test_redis_serializable() {
        #[derive(Debug, Serialize, Deserialize, PartialEq)]
        struct TestObject {
            id: String,
            name: String,
            value: i32,
        }
        
        // Implementar o trait RedisSerializable para TestObject
        impl RedisSerializable for TestObject {
            fn redis_key(&self) -> String {
                format!("test_object:{}", self.id)
            }
            
            // Não implementar save_to_redis e load_from_redis pois 
            // eles já são fornecidos pelo trait
        }
        
        let client = RedisClient::new("redis://127.0.0.1/", 5).unwrap();
        
        let obj = TestObject {
            id: "123".to_string(),
            name: "Test".to_string(),
            value: 42,
        };
        
        // Salva o objeto
        obj.save_to_redis(&client).await.unwrap();
        
        // Carrega o objeto
        let loaded = TestObject::load_from_redis("test_object:123", &client).await.unwrap();
        
        assert_eq!(loaded, Some(obj));
        
        // Limpa o objeto
        client.delete("test_object:123").await.unwrap();
    }
}use actix_web::{web, HttpResponse, Responder};
use serde::Serialize;
use crate::domain::identity::DID;
use crate::domain::blockchain::Block;
use crate::adapters::web::actix::{AppState, ApiResponse, error_to_http_response};

#[derive(Serialize)]
pub struct BlockResponse {
    pub block: Block,
    pub transactions_count: usize,
}

#[derive(Serialize)]
pub struct BlockchainStatusResponse {
    pub latest_block_number: u64,
    pub total_transactions: usize,
    pub is_synced: bool,
}

pub async fn get_block(
    app_state: web::Data<AppState>,
    block_number: web::Path<u64>,
) -> impl Responder {
    match app_state.blockchain_service.get_block(*block_number).await {
        Ok(Some(block)) => {
            let response = ApiResponse {
                success: true,
                data: Some(BlockResponse {
                    block: block.clone(),
                    transactions_count: block.transactions.len(),
                }),
                error: None,
            };
            
            HttpResponse::Ok().json(response)
        },
        Ok(None) => {
            let response = ApiResponse::<()> {
                success: false,
                data: None,
                error: Some(format!("Bloco {} não encontrado", block_number)),
            };
            
            HttpResponse::NotFound().json(response)
        },
        Err(e) => error_to_http_response(e),
    }
}

pub async fn get_latest_block(
    app_state: web::Data<AppState>,
) -> impl Responder {
    match app_state.blockchain_service.get_latest_block().await {
        Ok(block) => {
            let response = ApiResponse {
                success: true,
                data: Some(BlockResponse {
                    block: block.clone(),
                    transactions_count: block.transactions.len(),
                }),
                error: None,
            };
            
            HttpResponse::Ok().json(response)
        },
        Err(e) => error_to_http_response(e),
    }
}

pub async fn get_did_transactions(
    app_state: web::Data<AppState>,
    did_str: web::Path<String>,
) -> impl Responder {
    // Parseia o DID
    let did = match DID::parse(&did_str) {
        Ok(did) => did,
        Err(e) => {
            return HttpResponse::BadRequest().json(ApiResponse::<()> {
                success: false,
                data: None,
                error: Some(format!("DID inválido: {}", e)),
            });
        }
    };
    
    // Obtém as transações do DID
    match app_state.blockchain_service.get_did_transactions(&did).await {
        Ok(transactions) => {
            let response = ApiResponse {
                success: true,
                data: Some(transactions),
                error: None,
            };
            
            HttpResponse::Ok().json(response)
        },
        Err(e) => error_to_http_response(e),
    }
}

pub async fn sync_network(
    app_state: web::Data<AppState>,
) -> impl Responder {
    match app_state.blockchain_service.sync_with_network().await {
        Ok(()) => {
            // Após sincronizar, obtém o último bloco para informações de status
            match app_state.blockchain_service.get_latest_block().await {
                Ok(latest_block) => {
                    let status = BlockchainStatusResponse {
                        latest_block_number: latest_block.header.block_number,
                        total_transactions: latest_block.transactions.len(), // Isto é simplificado, idealmente contaria todas as transações
                        is_synced: true,
                    };
                    
                    let response = ApiResponse {
                        success: true,
                        data: Some(status),
                        error: None,
                    };
                    
                    HttpResponse::Ok().json(response)
                },
                Err(e) => error_to_http_response(e),
            }
        },
        Err(e) => error_to_http_response(e),
    }
} use actix_web::{web, HttpResponse, Responder};
use serde::{Deserialize, Serialize};
use crate::domain::identity::{DID, IdentityMetadata, VerificationStatus};
use crate::usecases::identity::IdentitySearchQuery;
use crate::adapters::web::actix::{AppState, ApiResponse, error_to_http_response};

#[derive(Deserialize)]
pub struct CreateIdentityRequest {
    pub public_key: String,
    pub display_name: Option<String>,
    pub device_id: Option<String>,
    pub attributes: Option<std::collections::HashMap<String, String>>,
}

#[derive(Deserialize)]
pub struct UpdateIdentityRequest {
    pub display_name: Option<String>,
    pub device_id: Option<String>,
    pub attributes: Option<std::collections::HashMap<String, String>>,
    pub verification_status: Option<VerificationStatus>,
}

#[derive(Deserialize)]
pub struct RevokeIdentityRequest {
    pub reason: String,
}

#[derive(Serialize)]
pub struct IdentityResponse {
    pub did: String,
    pub metadata: IdentityMetadata,
}

pub async fn create_identity(
    app_state: web::Data<AppState>,
    request: web::Json<CreateIdentityRequest>,
) -> impl Responder {
    // Construir metadados com base no request
    let mut metadata = IdentityMetadata::default();
    
    if let Some(display_name) = &request.display_name {
        metadata.display_name = Some(display_name.clone());
    }
    
    if let Some(device_id) = &request.device_id {
        metadata.device_id = Some(device_id.clone());
    }
    
    if let Some(attributes) = &request.attributes {
        metadata.attributes = attributes.clone();
    }
    
    // Criar identidade usando o serviço
    let did = DID::generate(&request.public_key);
    let did_string = did.to_string();
    match app_state.identity_service.as_async().create_identity(did, metadata).await {
        Ok(()) => {
            // Construir resposta
            let response = ApiResponse {
                success: true,
                data: Some(did_string),
                error: None,
            };
            
            HttpResponse::Created().json(response)
        },
        Err(e) => error_to_http_response(e),
    }
}

pub async fn get_identity(
    app_state: web::Data<AppState>,
    did_str: web::Path<String>,
) -> impl Responder {
    match app_state.identity_service.as_async().get_identity(&did_str).await {
        Ok(Some((did, metadata))) => {
            let response = ApiResponse {
                success: true,
                data: Some(IdentityResponse {
                    did: did.to_string(),
                    metadata,
                }),
                error: None,
            };
            
            HttpResponse::Ok().json(response)
        },
        Ok(None) => {
            let response = ApiResponse::<()> {
                success: false,
                data: None,
                error: Some("Identidade não encontrada".to_string()),
            };
            
            HttpResponse::NotFound().json(response)
        },
        Err(e) => error_to_http_response(e),
    }
}

pub async fn update_identity(
    app_state: web::Data<AppState>,
    did_str: web::Path<String>,
    request: web::Json<UpdateIdentityRequest>,
) -> impl Responder {
    // Primeiro, verifica se a identidade existe
    let identity_result = app_state.identity_service.as_async().get_identity(&did_str).await;
    
    match identity_result {
        Ok(Some((did, mut metadata))) => {
            // Atualiza os metadados com base no request
            if let Some(display_name) = &request.display_name {
                metadata.display_name = Some(display_name.clone());
            }
            
            if let Some(device_id) = &request.device_id {
                metadata.device_id = Some(device_id.clone());
            }
            
            if let Some(attributes) = &request.attributes {
                metadata.attributes.extend(attributes.clone());
            }
            
            if let Some(status) = &request.verification_status {
                metadata.verification_status = *status;
            }
            
            // Atualiza os metadados no serviço
            match app_state.identity_service.as_async().update_identity_metadata(&did, metadata).await {
                Ok(()) => {
                    let response = ApiResponse::<String> {
                        success: true,
                        data: Some("Identidade atualizada com sucesso".to_string()),
                        error: None,
                    };
                    
                    HttpResponse::Ok().json(response)
                },
                Err(e) => error_to_http_response(e),
            }
        },
        Ok(None) => {
            let response = ApiResponse::<()> {
                success: false,
                data: None,
                error: Some("Identidade não encontrada".to_string()),
            };
            
            HttpResponse::NotFound().json(response)
        },
        Err(e) => error_to_http_response(e),
    }
}

pub async fn revoke_identity(
    app_state: web::Data<AppState>,
    did_str: web::Path<String>,
    request: web::Json<RevokeIdentityRequest>,
) -> impl Responder {
    // Primeiro, parseia o DID
    match DID::parse(&did_str) {
        Ok(did) => {
            // Revoga a identidade
            match app_state.identity_service.as_async().revoke_identity(&did, &request.reason).await {
                Ok(()) => {
                    let response = ApiResponse::<String> {
                        success: true,
                        data: Some("Identidade revogada com sucesso".to_string()),
                        error: None,
                    };
                    
                    HttpResponse::Ok().json(response)
                },
                Err(e) => error_to_http_response(e),
            }
        },
        Err(e) => {
            let response = ApiResponse::<()> {
                success: false,
                data: None,
                error: Some(format!("DID inválido: {}", e)),
            };
            
            HttpResponse::BadRequest().json(response)
        }
    }
}

pub async fn verify_identity(
    app_state: web::Data<AppState>,
    did_str: web::Path<String>,
) -> impl Responder {
    // Parseia o DID
    match DID::parse(&did_str) {
        Ok(did) => {
            // Verifica a identidade
            match app_state.identity_service.as_async().verify_identity(&did).await {
                Ok(is_valid) => {
                    let response = ApiResponse {
                        success: true,
                        data: Some(is_valid),
                        error: None,
                    };
                    
                    HttpResponse::Ok().json(response)
                },
                Err(e) => error_to_http_response(e),
            }
        },
        Err(e) => {
            let response = ApiResponse::<()> {
                success: false,
                data: None,
                error: Some(format!("DID inválido: {}", e)),
            };
            
            HttpResponse::BadRequest().json(response)
        }
    }
}

pub async fn search_identities(
    app_state: web::Data<AppState>,
    query: web::Json<IdentitySearchQuery>,
) -> impl Responder {
    match app_state.identity_service.as_async().search_identities(query.into_inner()).await {
        Ok(results) => {
            let response_data: Vec<IdentityResponse> = results
                .into_iter()
                .map(|(did, metadata)| IdentityResponse {
                    did: did.to_string(),
                    metadata,
                })
                .collect();
                
            let response = ApiResponse {
                success: true,
                data: Some(response_data),
                error: None,
            };
            
            HttpResponse::Ok().json(response)
        },
        Err(e) => error_to_http_response(e),
    }
} use actix_web::{web, HttpResponse, Responder};
use serde::{Deserialize, Serialize};
use crate::domain::identity::DID;
use crate::domain::messaging::{Message, MessageType, MessagePriority};
use crate::usecases::messaging::MessageSearchQuery;
use crate::adapters::web::actix::{AppState, ApiResponse, error_to_http_response};
use chrono::{DateTime, Utc};

#[derive(Debug, Serialize, Deserialize)]
pub struct SendMessageRequest {
    pub recipient_did: DID,
    pub content: String,
    pub message_type: MessageType,
    pub priority: Option<MessagePriority>,
    pub conversation_id: Option<String>,
    pub tags: Option<Vec<String>>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct MarkAsReadRequest {
    pub message_id: String,
}

#[derive(Serialize)]
pub struct ConversationResponse {
    pub id: String,
    pub last_message: Option<DateTime<Utc>>,
    pub unread_count: i32,
}

pub async fn send_message(
    app_state: web::Data<AppState>,
    request: web::Json<SendMessageRequest>,
) -> impl Responder {
    let message = Message::new_text(
        app_state.identity.clone(),
        vec![request.recipient_did.clone()],
        &request.content,
        request.message_type.clone(),
    );
    
    match app_state.message_service.send_message_internal(message).await {
        Ok(message_id) => {
            let response = ApiResponse {
                success: true,
                data: Some(message_id),
                error: None,
            };
            
            HttpResponse::Ok().json(response)
        },
        Err(e) => error_to_http_response(e),
    }
}

pub async fn receive_messages(
    app_state: web::Data<AppState>,
) -> impl Responder {
    match app_state.message_service.receive_messages(100).await {
        Ok(messages) => {
            let response = ApiResponse {
                success: true,
                data: Some(messages),
                error: None,
            };
            
            HttpResponse::Ok().json(response)
        },
        Err(e) => error_to_http_response(e),
    }
}

pub async fn mark_as_read(
    app_state: web::Data<AppState>,
    message_id: web::Path<String>,
) -> impl Responder {
    match app_state.message_service.mark_as_read(&message_id).await {
        Ok(()) => {
            let response: ApiResponse<()> = ApiResponse {
                success: true,
                data: None,
                error: None,
            };
            
            HttpResponse::Ok().json(response)
        },
        Err(e) => error_to_http_response(e),
    }
}

pub async fn search_messages(
    app_state: web::Data<AppState>,
    query: web::Json<MessageSearchQuery>,
) -> impl Responder {
    match app_state.message_service.search_messages(query.into_inner()).await {
        Ok(messages) => {
            let response = ApiResponse {
                success: true,
                data: Some(messages),
                error: None,
            };
            
            HttpResponse::Ok().json(response)
        },
        Err(e) => error_to_http_response(e),
    }
}

pub async fn get_message(
    app_state: web::Data<AppState>,
    message_id: web::Path<String>,
) -> impl Responder {
    match app_state.message_service.get_message_by_id(&message_id).await {
        Ok(Some(message)) => {
            let response = ApiResponse {
                success: true,
                data: Some(message),
                error: None,
            };
            
            HttpResponse::Ok().json(response)
        },
        Ok(None) => {
            let response = ApiResponse::<()> {
                success: false,
                data: None,
                error: Some("Mensagem não encontrada".to_string()),
            };
            
            HttpResponse::NotFound().json(response)
        },
        Err(e) => error_to_http_response(e),
    }
}

pub async fn get_conversations(
    app_state: web::Data<AppState>,
) -> impl Responder {
    match app_state.message_service.get_conversations().await {
        Ok(conversations) => {
            let response = ApiResponse {
                success: true,
                data: Some(conversations),
                error: None,
            };
            
            HttpResponse::Ok().json(response)
        },
        Err(e) => error_to_http_response(e),
    }
}

pub async fn get_conversation_messages(
    app_state: web::Data<AppState>,
    conversation_id: web::Path<String>,
) -> impl Responder {
    match app_state.message_service.get_conversation_messages(&conversation_id).await {
        Ok(messages) => {
            let response = ApiResponse {
                success: true,
                data: Some(messages),
                error: None,
            };
            
            HttpResponse::Ok().json(response)
        },
        Err(e) => error_to_http_response(e),
    }
} pub mod identity;
pub mod messaging;
pub mod blockchain; use actix_web::{
    dev::{forward_ready, Service, ServiceRequest, ServiceResponse, Transform},
    error::Error,
    HttpMessage,
    FromRequest,
};
use crate::domain::identity::DID;
use crate::usecases::identity::IdentityService;
use futures::future::{ok, Ready, BoxFuture};
use std::future::Future;
use std::pin::Pin;
use std::sync::Arc;

/// Middleware de autenticação que verifica se um DID é válido
pub struct AuthMiddleware {
    identity_service: Arc<dyn IdentityService>,
}

impl AuthMiddleware {
    pub fn new(identity_service: Arc<dyn IdentityService>) -> Self {
        Self { identity_service }
    }
}

impl<S, B> Transform<S, ServiceRequest> for AuthMiddleware
where
    S: Service<ServiceRequest, Response = ServiceResponse<B>, Error = Error> + Clone + 'static,
    S::Future: 'static,
    B: 'static,
{
    type Response = ServiceResponse<B>;
    type Error = Error;
    type Transform = AuthMiddlewareService<S>;
    type InitError = ();
    type Future = Ready<Result<Self::Transform, Self::InitError>>;

    fn new_transform(&self, service: S) -> Self::Future {
        ok(AuthMiddlewareService {
            service,
            identity_service: self.identity_service.clone(),
        })
    }
}

pub struct AuthMiddlewareService<S> {
    service: S,
    identity_service: Arc<dyn IdentityService>,
}

impl<S, B> Service<ServiceRequest> for AuthMiddlewareService<S>
where
    S: Service<ServiceRequest, Response = ServiceResponse<B>, Error = Error> + Clone + 'static,
    S::Future: 'static,
    B: 'static,
{
    type Response = ServiceResponse<B>;
    type Error = Error;
    type Future = Pin<Box<dyn Future<Output = Result<Self::Response, Self::Error>>>>;

    forward_ready!(service);

 
    async fn revoke_identity(&self, did: &DID, reason: &str) -> Result<(), UseCaseError> {
        // Atualiza os metadados
        let mut identities = self.identities.write().await;
        if let Some(meta) = identities.get_mut(&did.to_string()) {
            meta.verification_status = VerificationStatus::Revoked;
            meta.updated_at = Utc::now();
            meta.attributes.insert("revocation_reason".to_string(), reason.to_string());
        }
        
        Ok(())
    }
    
    async fn verify_identity(&self, did: &DID) -> Result<bool, UseCaseError> {
        // Verifica se o DID existe na blockchain
        let transactions = self.blockchain_service.get_did_transactions(did).await?;
        if transactions.is_empty() {
            return Ok(false);
        }
        
        // Verifica se o DID foi revogado
        let identities = self.identities.read().await;
        if let Some(meta) = identities.get(&did.to_string()) {
            Ok(meta.verification_status != VerificationStatus::Revoked)
        } else {
            // Se não temos metadados, consideramos válido se está na blockchain
            Ok(true)
        }
    }
    
    async fn search_identities(&self, query: IdentitySearchQuery) -> Result<Vec<(DID, IdentityMetadata)>, UseCaseError> {
        let identities = self.identities.read().await;
        
        let mut results = Vec::new();
        
        for (did_str, metadata) in identities.iter() {
            // Ignora se não corresponde ao status de verificação
            if let Some(status) = query.verification_status {
                if metadata.verification_status != status {
                    continue;
                }
            }
            
            // Ignora se não corresponde ao nome de exibição
            if let Some(name) = &query.display_name {
                if let Some(display_name) = &metadata.display_name {
                    if !display_name.contains(name) {
                        continue;
                    }
                } else {
                    continue;
                }
            }
            
            // Ignora se não corresponde ao device_id
            if let Some(device_id) = &query.device_id {
                if let Some(meta_device_id) = &metadata.device_id {
                    if meta_device_id != device_id {
                        continue;
                    }
                } else {
                    continue;
                }
            }
            
            // Ignora se não corresponde aos atributos
            if let Some(attrs) = &query.attributes {
                let mut all_match = true;
                
                for (key, value) in attrs {
                    if let Some(attr_value) = metadata.attributes.get(key) {
                        if attr_value != value {
                            all_match = false;
                            break;
                        }
                    } else {
                        all_match = false;
                        break;
                    }
                }
                
                if !all_match {
                    continue;
                }
            }
            
            // Se chegou até aqui, a identidade corresponde aos critérios
            match DID::parse(did_str) {
                Ok(did) => results.push((did, metadata.clone())),
                Err(_) => continue, // Ignora DIDs inválidos
            }
        }
        
        // Aplica offset e limit
        if let Some(offset) = query.offset {
            if offset < results.len() {
                results = results.split_off(offset);
            } else {
                results.clear();
            }
        }
        
        if let Some(limit) = query.limit {
            if limit < results.len() {
                results.truncate(limit);
            }
        }
        
        Ok(results)
    }
}

impl IdentityService for BlockchainIdentityService {
    fn as_async(&self) -> &dyn AsyncIdentityService {
        self
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::usecases::blockchain::MockBlockchainService;
    
    #[tokio::test]
    async fn test_create_identity() {
        let mut mock_blockchain = MockBlockchainService::new();
        
        mock_blockchain.expect_register_did()
            .returning(|_, _| Ok("tx_id".to_string()));
            
        let identity_service = BlockchainIdentityService::new(Arc::new(mock_blockchain));
        
        let did = DID::generate("test_public_key");
        identity_service.create_identity(did.clone(), IdentityMetadata::default()).await.unwrap();
        
        assert_eq!(did.method(), "atous");
        assert_eq!(did.public_key_hash(), "test_public_key");
    }
    
    #[tokio::test]
    async fn test_get_identity() {
        let mut mock_blockchain = MockBlockchainService::new();
        
        // Configurar o mock
        mock_blockchain.expect_get_did_transactions()
            .returning(|_| Ok(vec![crate::domain::blockchain::Transaction::new(
                crate::domain::blockchain::TransactionType::RegisterDID,
                DID::generate("sender"),
                crate::domain::blockchain::TransactionPayload::DIDRegistration {
                    did: DID::generate("test"),
                    public_key: "test_key".to_string(),
                },
            )]));
            
        let identity_service = BlockchainIdentityService::new(Arc::new(mock_blockchain));
        
        // Criar uma identidade
        let did = DID::generate("test_key");
        
        // Adicionar metadados manualmente
        {
            let mut identities = identity_service.identities.write().await;
            identities.insert(did.to_string(), IdentityMetadata::default());
        }
        
        // Testar a obtenção da identidade
        let result = identity_service.get_identity(&did.to_string()).await.unwrap();
        
        assert!(result.is_some());
        let (found_did, _) = result.unwrap();
        assert_eq!(found_did.to_string(), did.to_string());
    }
    
    #[tokio::test]
    async fn test_update_identity_key() {
        let mut mock_blockchain = MockBlockchainService::default();
 
        mock_blockchain.expect_update_did()
            .returning(|_, _| Ok("tx_id".to_string()));
            
        let identity_service = BlockchainIdentityService::new(Arc::new(mock_blockchain));
        
        let did = DID::generate("old_key");
        
        {
            let mut identities = identity_service.identities.write().await;
            identities.insert(did.to_string(), IdentityMetadata::default());
        }
        
        identity_service.update_identity_key(&did, "new_key").await.unwrap();
    }
    
    #[tokio::test]
    async fn test_update_identity_metadata() {
        let mut mock_blockchain = MockBlockchainService::new();
        
        mock_blockchain.expect_get_did_transactions()
            .returning(|_| Ok(vec![crate::domain::blockchain::Transaction::new(
                crate::domain::blockchain::TransactionType::RegisterDID,
                DID::generate("sender"),
                crate::domain::blockchain::TransactionPayload::DIDRegistration {
                    did: DID::generate("test"),
                    public_key: "test_key".to_string(),
                },
            )]));
            
        let identity_service = BlockchainIdentityService::new(Arc::new(mock_blockchain));
        
        let did = DID::generate("test_key");
        
        {
            let mut identities = identity_service.identities.write().await;
            let mut meta = IdentityMetadata::default();
            meta.display_name = Some("Original Name".to_string());
            identities.insert(did.to_string(), meta);
        }
     
        let mut new_meta = IdentityMetadata::default();
        new_meta.display_name = Some("Updated Name".to_string());
        
        identity_service.update_identity_metadata(&did, new_meta.clone()).await.unwrap();
        
        // Verificar se os metadados foram atualizados
        let identities = identity_service.identities.read().await;
        let updated_meta = identities.get(&did.to_string()).unwrap();
        
        assert_eq!(updated_meta.display_name, Some("Updated Name".to_string()));
    }
    
    #[tokio::test]
    async fn test_revoke_identity() {
        let mut mock_blockchain = MockBlockchainService::new();
        
        // Configurar o mock
        mock_blockchain.expect_revoke_did()
            .returning(|_, _| Ok("tx_id".to_string()));
            
        let identity_service = BlockchainIdentityService::new(Arc::new(mock_blockchain));
        
        // Criar uma identidade
        let did = DID::generate("test_key");
        
        // Adicionar metadados manualmente
        {
            let mut identities = identity_service.identities.write().await;
            identities.insert(did.to_string(), IdentityMetadata::default());
        }
        
        // Testar a revogação
        identity_service.revoke_identity(&did, "Reason for revocation").await.unwrap();
        
        // Verificar se a identidade foi revogada
        let identities = identity_service.identities.read().await;
        let meta = identities.get(&did.to_string()).unwrap();
        
        assert_eq!(meta.verification_status, VerificationStatus::Revoked);
        assert_eq!(meta.attributes.get("revocation_reason").unwrap(), "Reason for revocation");
    }
    
    #[tokio::test]
    async fn test_search_identities() {
        let mock_blockchain = MockBlockchainService::new();
        let identity_service = BlockchainIdentityService::new(Arc::new(mock_blockchain));
        
        let did1 = DID::generate("key1");
        let did2 = DID::generate("key2");
        let did3 = DID::generate("key3");
        
        {
            let mut identities = identity_service.identities.write().await;
            
            let mut meta1 = IdentityMetadata::default();
            meta1.display_name = Some("User One".to_string());
            meta1.device_id = Some("device1".to_string());
            meta1.attributes.insert("role".to_string(), "admin".to_string());
            
            let mut meta2 = IdentityMetadata::default();
            meta2.display_name = Some("User Two".to_string());
            meta2.device_id = Some("device2".to_string());
            meta2.attributes.insert("role".to_string(), "user".to_string());
            
            let mut meta3 = IdentityMetadata::default();
            meta3.display_name = Some("Admin Three".to_string());
            meta3.device_id = Some("device3".to_string());
            meta3.attributes.insert("role".to_string(), "admin".to_string());
            
            identities.insert(did1.to_string(), meta1);
            identities.insert(did2.to_string(), meta2);
            identities.insert(did3.to_string(), meta3);
        }
        
        let query1 = IdentitySearchQuery {
            display_name: Some("Admin".to_string()),
            verification_status: None,
            device_id: None,
            attributes: None,
            limit: None,
            offset: None,
        };
        
        let results1 = identity_service.search_identities(query1).await.unwrap();
        assert_eq!(results1.len(), 1);
        assert_eq!(results1[0].1.display_name, Some("Admin Three".to_string()));
        
        let mut attrs = HashMap::new();
        attrs.insert("role".to_string(), "admin".to_string());
        
        let query2 = IdentitySearchQuery {
            display_name: None,
            verification_status: None,
            device_id: None,
            attributes: Some(attrs),
            limit: None,
            offset: None,
        };
        
        let results2 = identity_service.search_identities(query2).await.unwrap();
        assert_eq!(results2.len(), 2); // Dois usuários com role=admin
    }
} use crate::domain::identity::DID;
use crate::domain::messaging::{Message, MessageContent, MessageType, MessageState};
use crate::usecases::error::UseCaseError;
use crate::usecases::blockchain::BlockchainService;
use async_trait::async_trait;
use chrono::Utc;
use serde::{Serialize, Deserialize};
use std::sync::Arc;
use redis::RedisError;

impl From<RedisError> for UseCaseError {
    fn from(err: RedisError) -> Self {
        UseCaseError::Database(err)
    }
}

#[async_trait]
pub trait MessageSender: Send + Sync {
    async fn send_message(&self, message: Message) -> Result<String, UseCaseError>;
}

#[async_trait]
pub trait MessageReceiver: Send + Sync {
    async fn receive_messages(&self, limit: usize) -> Result<Vec<Message>, UseCaseError>;
    async fn mark_as_read(&self, message_id: &str) -> Result<(), UseCaseError>;
}

#[async_trait]
pub trait MessageQuery: Send + Sync {
    async fn search_messages(&self, query: MessageSearchQuery) -> Result<Vec<Message>, UseCaseError>;
    async fn get_message_by_id(&self, message_id: &str) -> Result<Option<Message>, UseCaseError>;
}

#[async_trait]
pub trait ConversationQuery: Send + Sync {
    async fn get_conversations(&self) -> Result<Vec<String>, UseCaseError>;
    async fn get_conversation_messages(&self, conversation_id: &str) -> Result<Vec<Message>, UseCaseError>;
}

#[async_trait]
pub trait MessageService: Send + Sync {
    async fn send_message_internal(&self, message: Message) -> Result<String, UseCaseError>;
    async fn receive_messages(&self, limit: usize) -> Result<Vec<Message>, UseCaseError>;
    async fn mark_as_read(&self, message_id: &str) -> Result<(), UseCaseError>;
    async fn search_messages(&self, query: MessageSearchQuery) -> Result<Vec<Message>, UseCaseError>;
    async fn get_message_by_id(&self, message_id: &str) -> Result<Option<Message>, UseCaseError>;
    async fn get_conversations(&self) -> Result<Vec<String>, UseCaseError>;
    async fn get_conversation_messages(&self, conversation_id: &str) -> Result<Vec<Message>, UseCaseError>;
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageSearchQuery {
    pub user_did: DID,
    pub conversation_id: Option<String>,
    pub sender_did: Option<DID>,
    pub contains_text: Option<String>,
    pub message_type: Option<MessageType>,
    pub states: Option<Vec<MessageState>>,
    pub from_date: Option<chrono::DateTime<chrono::Utc>>,
    pub to_date: Option<chrono::DateTime<chrono::Utc>>,
    pub tags: Option<Vec<String>>,
    pub limit: Option<usize>,
    pub offset: Option<usize>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageStats {
    pub total_messages: usize,
    pub unread_messages: usize,
    pub conversations: usize,
    pub sent_today: usize,
    pub received_today: usize,
}

pub struct RedisMessageService {
    redis_client: redis::Client,
    blockchain_service: Option<Arc<dyn BlockchainService>>,
}

impl RedisMessageService {
    pub fn new(redis_url: &str) -> Result<Self, UseCaseError> {
        let redis_client = redis::Client::open(redis_url)?;
            
        Ok(Self {
            redis_client,
            blockchain_service: None,
        })
    }
    
    pub fn with_blockchain_service(
        mut self,
        blockchain_service: Arc<dyn BlockchainService>,
    ) -> Self {
        self.blockchain_service = Some(blockchain_service);
        self
    }
    
    async fn register_message_hash(&self, message: &Message) -> Result<Option<String>, UseCaseError> {
        if let Some(blockchain_service) = &self.blockchain_service {
            let message_hash = message.calculate_hash()
                .map_err(|e| UseCaseError::Internal(format!("Falha ao calcular hash: {}", e)))?;
                
            let tx_id = blockchain_service.register_message_metadata(
                &message.sender,
                &message.recipients,
                &message_hash,
            ).await?;
            
            Ok(Some(tx_id))
        } else {
            Ok(None)
        }
    }
    
    async fn store_message(&self, message: &Message) -> Result<(), UseCaseError> {
        let mut conn = self.redis_client.get_multiplexed_tokio_connection().await?;
            
        let message_json = serde_json::to_string(message)
            .map_err(|e| UseCaseError::Internal(format!("Erro de serialização: {}", e)))?;
            
        let _: () = redis::cmd("SET")
            .arg(format!("message:{}", message.id))
            .arg(message_json.clone())
            .query_async::<_, ()>(&mut conn)
            .await?;
            
        for recipient in &message.recipients {
            let _: () = redis::cmd("LPUSH")
                .arg(format!("user:{}:messages", recipient))
                .arg(&message.id)
                .query_async::<_, ()>(&mut conn)
                .await?;
         
            if let Some(conv_id) = &message.metadata.conversation_id {
                let _: () = redis::cmd("LPUSH")
                    .arg(format!("conversation:{}:messages", conv_id))
                    .arg(&message.id)
                    .query_async::<_, ()>(&mut conn)
                    .await?;
                let _: () = redis::cmd("SADD")
                    .arg(format!("user:{}:conversations", recipient))
                    .arg(conv_id)
                    .query_async::<_, ()>(&mut conn)
                    .await?;
            }
        }
        
        let _: () = redis::cmd("LPUSH")
            .arg(format!("user:{}:sent", message.sender))
            .arg(&message.id)
            .query_async::<_, ()>(&mut conn)
            .await?;
            
        Ok(())
    }
    
    fn message_matches_query(&self, message: &Message, query: &MessageSearchQuery) -> bool {
        if let Some(sender_did) = &query.sender_did {
            if &message.sender != sender_did {
                return false;
            }
        }
        
        if let Some(message_type) = &query.message_type {
            if &message.metadata.message_type != message_type {
                return false;
            }
        }
        
        if let Some(states) = &query.states {
            if !states.contains(&message.metadata.state) {
                return false;
            }
        }
        
        if let Some(from_date) = query.from_date {
            if message.timestamp < from_date {
                return false;
            }
        }
        
        if let Some(to_date) = query.to_date {
            if message.timestamp > to_date {
                return false;
            }
        }
        
        if let Some(tags) = &query.tags {
            if !tags.iter().all(|tag| message.metadata.tags.contains(tag)) {
                return false;
            }
        }
        
        if let Some(text) = &query.contains_text {
            match &message.content {
                MessageContent::Plaintext(content) => {
                    if !content.to_lowercase().contains(&text.to_lowercase()) {
                        return false;
                    }
                }
                _ => return false, 
            }
        }
        
        true
    }
}

#[async_trait]
impl MessageService for RedisMessageService {
    async fn send_message_internal(&self, mut message: Message) -> Result<String, UseCaseError> {
        message.update_state(MessageState::Sending);
        
        if let Some(tx_id) = self.register_message_hash(&message).await? {
            message.set_blockchain_tx_id(tx_id);
        }
        
        let now = Utc::now();
        message.timestamp = now;
        message.update_state(MessageState::Delivered);
        
        self.store_message(&message).await?;
        
        Ok(message.id.clone())
    }
    
    async fn receive_messages(&self, limit: usize) -> Result<Vec<Message>, UseCaseError> {
        let mut conn = self.redis_client.get_multiplexed_tokio_connection().await?;   
        let message_ids: Result<Vec<String>, RedisError> = redis::cmd("LRANGE")
            .arg("messages")
            .arg(0)
            .arg((limit - 1) as isize)
            .query_async::<_, Vec<String>>(&mut conn)
            .await;
            
        let mut messages = Vec::new();
        for id in message_ids? {
            let message_json: Option<String> = redis::cmd("GET")
                .arg(format!("message:{}", id))
                .query_async::<_, Option<String>>(&mut conn)
                .await?;
                
            if let Some(json) = message_json {
                let message: Message = serde_json::from_str(&json)
                    .map_err(|e| UseCaseError::Internal(format!("Erro ao deserializar mensagem: {}", e)))?;
                messages.push(message);
            }
        }
        
        Ok(messages)
    }
    
    async fn mark_as_read(&self, message_id: &str) -> Result<(), UseCaseError> {
        let mut conn = self.redis_client.get_multiplexed_tokio_connection().await?;
            
        let message_json: Option<String> = redis::cmd("GET")
            .arg(format!("message:{}", message_id))
            .query_async::<_, Option<String>>(&mut conn)
            .await?;
            
        if let Some(json) = message_json {
            let mut message: Message = serde_json::from_str(&json)
                .map_err(|e| UseCaseError::Internal(format!("Erro ao deserializar mensagem: {}", e)))?;
                
            message.update_state(MessageState::Read);
       
            let updated_json = serde_json::to_string(&message)
                .map_err(|e| UseCaseError::Internal(format!("Erro ao serializar mensagem: {}", e)))?;
                
            let _: () = redis::cmd("SET")
                .arg(format!("message:{}", message_id))
                .arg(updated_json)
                .query_async::<_, ()>(&mut conn)
                .await?;
                
            Ok(())
        } else {
            Err(UseCaseError::NotFound(format!("Mensagem {} não encontrada", message_id)))
        }
    }
    
    async fn search_messages(&self, query: MessageSearchQuery) -> Result<Vec<Message>, UseCaseError> {
        let mut conn = self.redis_client.get_multiplexed_tokio_connection().await?;
            
        let key = if let Some(ref conv_id) = query.conversation_id {
            format!("conversation:{}:messages", conv_id)
        } else {
            format!("user:{}:messages", query.user_did)
        };
        
        let message_ids: Result<Vec<String>, RedisError> = redis::cmd("LRANGE")
            .arg(&key)
            .arg(0)
            .arg(999)
            .query_async::<_, Vec<String>>(&mut conn)
            .await;
            
        let mut messages = Vec::new();
        for id in message_ids? {
            let message_json: Option<String> = redis::cmd("GET")
                .arg(format!("message:{}", id))
                .query_async::<_, Option<String>>(&mut conn)
                .await?;
                
            if let Some(json) = message_json {
                let message: Message = serde_json::from_str(&json)
                    .map_err(|e| UseCaseError::Internal(format!("Erro ao deserializar mensagem: {}", e)))?;
                    
                if self.message_matches_query(&message, &query) {
                    messages.push(message);
                }
            }
        }
        
        if let Some(offset) = query.offset {
            if offset < messages.len() {
                messages = messages.split_off(offset);
            } else {
                messages.clear();
            }
        }
        
        if let Some(limit) = query.limit {
            if limit < messages.len() {
                messages.truncate(limit);
            }
        }
        
        Ok(messages)
    }
    
    async fn get_message_by_id(&self, message_id: &str) -> Result<Option<Message>, UseCaseError> {
        let mut conn = self.redis_client.get_multiplexed_tokio_connection().await?;
            
        let message_json: Option<String> = redis::cmd("GET")
            .arg(format!("message:{}", message_id))
            .query_async::<_, Option<String>>(&mut conn)
            .await?;
            
        match message_json {
            Some(json) => {
                let message: Message = serde_json::from_str(&json)
                    .map_err(|e| UseCaseError::Internal(format!("Erro ao deserializar mensagem: {}", e)))?;
                Ok(Some(message))
            }
            None => Ok(None),
        }
    }
    
    async fn get_conversations(&self) -> Result<Vec<String>, UseCaseError> {
        let mut conn = self.redis_client.get_multiplexed_tokio_connection().await?;
            
        let conversation_ids: Result<Vec<String>, RedisError> = redis::cmd("SMEMBERS")
            .arg("conversations")
            .query_async::<_, Vec<String>>(&mut conn)
            .await;
            
        Ok(conversation_ids?)
    }
    
    async fn get_conversation_messages(&self, conversation_id: &str) -> Result<Vec<Message>, UseCaseError> {
        let mut conn = self.redis_client.get_multiplexed_tokio_connection().await?;
            
        let message_ids: Vec<String> = redis::cmd("LRANGE")
            .arg(format!("conversation:{}:messages", conversation_id))
            .arg(0)
            .arg(-1)
            .query_async::<_, Vec<String>>(&mut conn)
            .await?;
            
        let mut messages = Vec::new();
        for id in message_ids {
            let message_json: Option<String> = redis::cmd("GET")
                .arg(format!("message:{}", id))
                .query_async::<_, Option<String>>(&mut conn)
                .await?;
                
            if let Some(json) = message_json {
                let message: Message = serde_json::from_str(&json)
                    .map_err(|e| UseCaseError::Internal(format!("Erro ao deserializar mensagem: {}", e)))?;
                messages.push(message);
            }
        }
        
        Ok(messages)
    }
}

#[async_trait]
impl MessageSender for RedisMessageService {
    async fn send_message(&self, message: Message) -> Result<String, UseCaseError> {
        self.send_message_internal(message).await
    }
} pub mod messaging;
pub mod blockchain;
pub mod identity;
pub mod error;

pub use error::UseCaseError; pub mod websocket;
pub use network::error::NetworkResult;
pub use network::error::NetworkError;
pub const VERSION: &str = env!("CARGO_PKG_VERSION");

pub mod domain;
pub mod usecases;
pub mod adapters;
pub mod config;

pub use domain::identity::DID;
pub use domain::blockchain::Transaction;
pub use usecases::messaging::MessageService;
pub use usecases::blockchain::BlockchainService;
pub use usecases::identity::IdentityService;

pub fn init() {
    env_logger::init();
}

#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}

pub fn version_info() -> String {
    format!("Atous Network v{} - P2P Network Backend", VERSION)
} use anyhow::Result;
use log::{info, error};
use std::sync::Arc;
use tokio::runtime;
use clap::{Arg, Command, ArgMatches};
use atous::{
    config::Config,
    domain::identity::DID,
    usecases::{
        messaging::RedisMessageService,
        blockchain::FileBlockchainService,
        identity::BlockchainIdentityService
    },
    adapters::{
        crypto::pqc::{PQCProvider, create_sign_function, create_verify_function},
        persistence::redis::RedisClient,
        network::p2p::{P2PNetwork, MessageBridgeHandler},
        web::actix::run_server
    },
};
use std::io::Read;

// Em vez de usar o macro #[tokio::main], implementamos a função main manualmente
fn main() -> Result<()> {
    // Criar um runtime tokio
    let rt = runtime::Builder::new_multi_thread()
        .enable_all()
        .build()?;
    
    // Executar a função assíncrona no runtime
    rt.block_on(async_main())
}

// Nossa função principal assíncrona
async fn async_main() -> Result<()> {
    // Processa argumentos da linha de comando
    let matches = Command::new("Atous Network Node")
        .version("0.1.0")
        .author("Atous Network Team")
        .about("Nó da rede Atous para identidade descentralizada e comunicação segura")
        .arg(
            Arg::new("config")
                .short('c')
                .long("config")
                .value_name("FILE")
                .help("Caminho para o arquivo de configuração"),
        )
        .arg(
            Arg::new("bootstrap")
                .long("bootstrap")
                .action(clap::ArgAction::SetTrue)
                .help("Inicia o nó em modo bootstrap"),
        )
        .arg(
            Arg::new("validator")
                .long("validator")
                .action(clap::ArgAction::SetTrue)
                .help("Inicia o nó em modo validador"),
        )
        .arg(
            Arg::new("light")
                .long("light")
                .action(clap::ArgAction::SetTrue)
                .help("Inicia o nó em modo leve (sem participar do consenso)"),
        )
        .subcommand(
            Command::new("keygen")
                .about("Gera um novo par de chaves")
                .arg(
                    Arg::new("output")
                        .short('o')
                        .long("output")
                        .value_name("DIR")
                        .help("Diretório de saída"),
                ),
        )
        .get_matches();

    // Verifica se é uma operação de geração de chaves
    if let Some(("keygen", sub_m)) = matches.subcommand() {
        return generate_keys(sub_m).map_err(anyhow::Error::from);
    }

    // Carrega a configuração
    let mut config = if let Some(config_path) = matches.get_one::<String>("config").map(|s| s.as_str()) {
        Config::from_file(config_path)?
    } else {
        Config::from_env()?
    };

    // Sobrescreve o modo do nó se especificado na linha de comando
    if matches.get_flag("bootstrap") {
        config.node.mode = atous::config::NodeMode::Bootstrap;
    } else if matches.get_flag("validator") {
        config.node.mode = atous::config::NodeMode::Validator;
    } else if matches.get_flag("light") {
        config.node.mode = atous::config::NodeMode::Light;
    }

    // Configura o logging
    config.setup_logging();

    info!("Iniciando nó Atous '{}' em modo {:?}", config.node.name, config.node.mode);
    
    // Inicializa o provedor de criptografia
    let mut crypto_provider = PQCProvider::new();
    
    // Carrega ou gera chaves
    let node_did = if let Some(pk_path) = &config.security.public_key_path {
        if let Some(sk_path) = &config.security.private_key_path {
            info!("Carregando chaves existentes...");
            // Carrega chaves de arquivos
            let mut public_key = String::new();
            std::fs::File::open(pk_path)?.read_to_string(&mut public_key)?;
            
            let mut private_key = String::new();
            std::fs::File::open(sk_path)?.read_to_string(&mut private_key)?;
            
            crypto_provider.load_keys(&public_key, Some(&private_key))?;
            
            // Cria o DID a partir da chave pública
            DID::new(config.node.name.clone(), &crypto_provider.get_public_key_hash()?)
        } else if let Some(pk_b64) = &config.security.public_key_base64 {
            info!("Carregando chave pública existente...");
            // Carrega apenas a chave pública
            crypto_provider.load_keys(pk_b64, None)?;
            
            // Cria o DID a partir da chave pública
            DID::new(config.node.name.clone(), &crypto_provider.get_public_key_hash()?)
        } else {
            // Gera novas chaves
            info!("Gerando novo par de chaves...");
            let (public_key, private_key) = crypto_provider.generate_keypair()?;
            
            // Salva as chaves
            std::fs::create_dir_all(pk_path.parent().unwrap())?;
            std::fs::write(pk_path, &public_key)?;
            
            if let Some(sk_path) = &config.security.private_key_path {
                std::fs::write(sk_path, &private_key)?;
            }
            
            // Cria o DID a partir da chave pública
            DID::new(config.node.name.clone(), &crypto_provider.get_public_key_hash()?)
        }
    } else {
        // Gera chaves temporárias (sem persistência)
        info!("Gerando par de chaves temporário...");
        let (_public_key, _private_key) = crypto_provider.generate_keypair()?;
        
        // Cria o DID a partir da chave pública
        DID::new(config.node.name.clone(), &crypto_provider.get_public_key_hash()?)
    };
    
    info!("DID do nó: {}", node_did);
    
    // Cria as funções de assinatura e verificação
    let crypto_provider_arc = Arc::new(crypto_provider);
    let sign_fn1 = create_sign_function(crypto_provider_arc.clone());
    let verify_fn1 = create_verify_function(crypto_provider_arc.clone());
    
    // Inicializa os serviços
    
    // 1. Cliente Redis
    let _redis_client = RedisClient::new(&config.persistence.redis_url, config.persistence.redis_pool_size)?;
    
    // 2. Serviço de blockchain
    let blockchain_service = Arc::new(FileBlockchainService::new(
        &config.blockchain.path,
        node_did.clone(),
        sign_fn1,
        verify_fn1,
    )?);
    // Initialize blockchain
    blockchain_service.load_or_init_blockchain().await?;
    
    // 3. Serviço de identidade
    let identity_service = Arc::new(BlockchainIdentityService::new(blockchain_service.clone()));
    
    // 4. Serviço de mensagens
    let sign_fn2 = create_sign_function(crypto_provider_arc.clone());
    let verify_fn2 = create_verify_function(crypto_provider_arc.clone());
    let blockchain_service2 = Arc::new(FileBlockchainService::new(
            &config.blockchain.path,
            node_did.clone(),
            sign_fn2,
            verify_fn2,
        )?);
    blockchain_service2.load_or_init_blockchain().await?;
    let message_service = Arc::new(RedisMessageService::new(&config.persistence.redis_url)?
        .with_blockchain_service(blockchain_service2));
    
    // 5. Rede P2P
    let p2p_network = if config.node.mode == atous::config::NodeMode::Bootstrap {
        // Bootstrap node doesn't need initial peers
        P2PNetwork::new(
            &config.node.name,
            vec![],
            true,
        ).await?
    } else {
        // Non-bootstrap nodes need bootstrap peers
        P2PNetwork::new(
            &config.node.name,
            config.network.bootstrap_peers.clone(),
            false,
        ).await?
    };
    
    // Registra o DID local na rede
    let mut p2p = p2p_network;
    p2p.set_local_did(node_did.clone()).await;
    
    // Cria um handler para mensagens
    let message_bridge_handler = Box::new(
        MessageBridgeHandler::new(message_service.clone())
    );
    
    // Adiciona o handler à rede
    p2p.add_message_handler(message_bridge_handler).await;
    
    // Inicia a rede P2P
    p2p.start(&config.network.p2p_listen).await?;
    
    // Inicia o servidor web se estiver habilitado
    if config.web.enabled {
        if let Err(e) = run_server(
            &config.web.listen,
            config.web.port,
            identity_service,
            message_service,
            blockchain_service,
        ).await {
            error!("Erro ao iniciar servidor web: {}", e);
        }
    }
    
    loop {
        tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
    }
}
fn generate_keys(matches: &ArgMatches) -> Result<(), anyhow::Error> {
    let output_dir = matches.get_one::<String>("output").map(|s| s.as_str()).unwrap_or("./keys");
    let output_path = std::path::Path::new(output_dir);

    std::fs::create_dir_all(output_path)?;
    
    let mut crypto_provider = PQCProvider::new();
    let (public_key, private_key) = crypto_provider.generate_keypair()?;
    
    let public_key_hash = crypto_provider.get_public_key_hash()?;
    
    let public_key_path = output_path.join("public_key.pem");
    let private_key_path = output_path.join("private_key.pem");
    let did_path = output_path.join("did.txt");
    
    std::fs::write(&public_key_path, &public_key)?;
    std::fs::write(&private_key_path, &private_key)?;
    
    let did = DID::new("generated", &public_key_hash);
    std::fs::write(&did_path, did.to_string())?;
    
    println!("Chaves geradas com sucesso!");
    println!("  Chave pública: {}", public_key_path.display());
    println!("  Chave privada: {}", private_key_path.display());
    println!("  DID: {}", did);

    Ok(())
} use warp::ws::{WebSocket, Message};
use std::sync::Arc;
use tokio::sync::Mutex;
use network::error::{NetworkResult, NetworkError};
use futures::stream::SplitSink;
use serde::Deserialize;

#[derive(Debug, Deserialize)]
#[serde(tag = "type", content = "payload")]
enum Command {

    #[serde(rename = "offline_status")]
    OfflineStatus,
    
    #[serde(rename = "pending_messages")]
    PendingMessages,
}

// #[derive(Debug)]
// enum ConnectionState {
//     Online,
//     Offline,
//     Degraded,
// }

#[allow(dead_code)]
async fn send_response(
    _tx: &mut SplitSink<WebSocket, Message>,
    success: bool,
    message: &str,
    data: Option<serde_json::Value>,
) -> Result<(), warp::Error> {
    let response = serde_json::json!({
        "success": success,
        "message": message,
        "data": data,
    });
    let _msg = Message::text(response.to_string());
    // _tx.send(_msg).await?;
    Ok(())
}

#[allow(dead_code)]
async fn process_message<NetworkManager>(
    message: &str, 
    _tx: &mut SplitSink<WebSocket, Message>,
    network: &Arc<Mutex<NetworkManager>>
) -> NetworkResult<()> {

    let command: Command = serde_json::from_str(message)
        .map_err(|e| NetworkError::from(format!("Erro ao decodificar comando: {}", e)))?;
    
    match command {  
        Command::OfflineStatus => {
            let _network_manager = network.lock().await;
            
            // Comment out or update the use of network_manager.connectivity to match actual fields.
            // let status = if let Some(detector) = &network_manager.connectivity {
            //     match detector.get_state() {
            //         ConnectionState::Online => "online",
            //         ConnectionState::Offline => "offline",
            //         ConnectionState::Degraded => "degraded",
            //     }
            // } else {
            //     "unknown"
            // };
            
            // Comment out or update the use of network_manager.message_queue to match actual fields.
            // let pending = if let Some(queue) = &network_manager.message_queue {
            //     queue.pending_count()
            // } else {
            //     0
            // };
            
            // Comment out or update the use of network_manager.connectivity and network_manager.message_queue to match actual fields.
            // let status_json = serde_json::json!({
            //     "status": status,
            //     "pending_messages": pending,
            // });
            
            // send_response(tx, true, "Status de conexão", Some(status_json)).await.map_err(|e| NetworkError::from(e.to_string()))?;
        },
        
        Command::PendingMessages => {
            let _network_manager = network.lock().await;
            
            // Comment out or update the use of network_manager.message_queue to match actual fields.
            // let pending_json = if let Some(queue) = &network_manager.message_queue {
            //     // Na implementação real, retornaria a lista de mensagens pendentes
            //     // Simplificado aqui para apenas o número
            //     serde_json::json!({
            //         "count": queue.pending_count(),
            //     })
            // } else {
            //     serde_json::json!({
            //         "count": 0,
            //     })
            // };
            
            // Comment out or update the use of network_manager.message_queue to match actual fields.
            // send_response(tx, true, "Mensagens pendentes", Some(pending_json)).await.map_err(|e| NetworkError::from(e.to_string()))?;
        },
    }
    
    Ok(())
}use anyhow::Result;
use atous::adapters::network::p2p::P2PNetwork;
use atous::config::NetworkConfig;
use std::sync::Arc;
use tokio::sync::Mutex;
use tokio::runtime::Runtime;

#[test]
fn test_network_manager_init() -> Result<()> {
 
    let rt = Runtime::new()?;
    
    rt.block_on(async {
        let _config = NetworkConfig::default();
        let _network = P2PNetwork::new(
            "test_node",
            vec![],
            false
        ).await?;
        
        Ok(())